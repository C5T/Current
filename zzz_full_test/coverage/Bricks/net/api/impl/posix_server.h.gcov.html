<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - Bricks/net/api/impl/posix_server.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">Bricks/net/api/impl</a> - posix_server.h<span style="font-size: 80%;"> (source / <a href="posix_server.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">99</td>
            <td class="headerCovTableEntry">99</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2015-02-24 12:16:30</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">45</td>
            <td class="headerCovTableEntry">49</td>
            <td class="headerCovTableEntryHi">91.8 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /*******************************************************************************</a>
<span class="lineNum">       2 </span>            : The MIT License (MIT)
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : Copyright (c) 2014 Dmitry &quot;Dima&quot; Korolev, &lt;dmitry.korolev@gmail.com&gt;.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : Permission is hereby granted, free of charge, to any person obtaining a copy
<span class="lineNum">       7 </span>            : of this software and associated documentation files (the &quot;Software&quot;), to deal
<span class="lineNum">       8 </span>            : in the Software without restriction, including without limitation the rights
<span class="lineNum">       9 </span>            : to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
<span class="lineNum">      10 </span>            : copies of the Software, and to permit persons to whom the Software is
<span class="lineNum">      11 </span>            : furnished to do so, subject to the following conditions:
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : The above copyright notice and this permission notice shall be included in all
<span class="lineNum">      14 </span>            : copies or substantial portions of the Software.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
<span class="lineNum">      17 </span>            : IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
<span class="lineNum">      18 </span>            : FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
<span class="lineNum">      19 </span>            : AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
<span class="lineNum">      20 </span>            : LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
<span class="lineNum">      21 </span>            : OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
<span class="lineNum">      22 </span>            : SOFTWARE.
<span class="lineNum">      23 </span>            : *******************************************************************************/
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : // TODO(dkorolev): Handle empty POST body. Add a test for it.
<span class="lineNum">      26 </span>            : // TODO(dkorolev): Support receiving body via POST requests. Add a test for it.
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #ifndef BRICKS_NET_API_POSIX_SERVER_H
<span class="lineNum">      29 </span>            : #define BRICKS_NET_API_POSIX_SERVER_H
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : #include &lt;atomic&gt;
<span class="lineNum">      32 </span>            : #include &lt;string&gt;
<span class="lineNum">      33 </span>            : #include &lt;map&gt;
<span class="lineNum">      34 </span>            : #include &lt;memory&gt;
<span class="lineNum">      35 </span>            : #include &lt;thread&gt;
<span class="lineNum">      36 </span>            : #include &lt;iostream&gt;  // TODO(dkorolev): More robust logging here.
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : #include &quot;../types.h&quot;
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #include &quot;../../exceptions.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;../../http/http.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;../../url/url.h&quot;
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : #include &quot;../../../strings/printf.h&quot;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : namespace bricks {
<span class="lineNum">      47 </span>            : namespace net {
<a name="48"><span class="lineNum">      48 </span>            : namespace api {</a>
<a name="49"><span class="lineNum">      49 </span>            : </a>
<span class="lineNum">      50 </span><span class="lineCov">         24 : struct HandlerAlreadyExistsException : HTTPException {</span>
<span class="lineNum">      51 </span><span class="lineCov">          8 :   explicit HandlerAlreadyExistsException(const std::string&amp; what) { SetWhat(what); }</span>
<a name="52"><span class="lineNum">      52 </span>            : };</a>
<a name="53"><span class="lineNum">      53 </span>            : </a>
<span class="lineNum">      54 </span><span class="lineCov">          6 : struct HandlerDoesNotExistException : HTTPException {</span>
<span class="lineNum">      55 </span><span class="lineCov">          2 :   explicit HandlerDoesNotExistException(const std::string&amp; what) { SetWhat(what); }</span>
<span class="lineNum">      56 </span>            : };
<a name="57"><span class="lineNum">      57 </span>            : </a>
<span class="lineNum">      58 </span>            : // The only parameter to be passed to HTTP handlers.
<span class="lineNum">      59 </span><span class="lineCov">        374 : struct Request final {</span>
<span class="lineNum">      60 </span>            :   std::unique_ptr&lt;HTTPServerConnection&gt; unique_connection;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :   HTTPServerConnection&amp; connection;
<span class="lineNum">      63 </span>            :   const HTTPRequestData&amp; http_data;  // Accessor to use `r.http_data` instead of `r.connection-&gt;HTTPRequest()`.
<span class="lineNum">      64 </span>            :   const url::URL&amp; url;
<span class="lineNum">      65 </span>            :   const std::string method;
<span class="lineNum">      66 </span>            :   const bool has_body;
<span class="lineNum">      67 </span>            :   const std::string empty_string = &quot;&quot;;
<a name="68"><span class="lineNum">      68 </span>            :   const std::string&amp; body;  // TODO(dkorolev): This is inefficient, but will do.</a>
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span><span class="lineCov">        116 :   explicit Request(std::unique_ptr&lt;HTTPServerConnection&gt;&amp;&amp; connection)</span>
<span class="lineNum">      71 </span><span class="lineCov">        116 :       : unique_connection(std::move(connection)),</span>
<span class="lineNum">      72 </span><span class="lineCov">        116 :         connection(*unique_connection.get()),</span>
<span class="lineNum">      73 </span><span class="lineCov">        116 :         http_data(unique_connection-&gt;HTTPRequest()),</span>
<span class="lineNum">      74 </span><span class="lineCov">        116 :         url(http_data.URL()),</span>
<span class="lineNum">      75 </span><span class="lineCov">        116 :         method(http_data.Method()),</span>
<span class="lineNum">      76 </span><span class="lineCov">        116 :         has_body(http_data.HasBody()),</span>
<span class="lineNum">      77 </span><span class="lineCov">        696 :         body(has_body ? http_data.Body() : empty_string) {}</span>
<a name="78"><span class="lineNum">      78 </span>            : </a>
<span class="lineNum">      79 </span>            :   // It is essential to move `unique_connection` so that the socket outlives the destruction of `rhs`.
<span class="lineNum">      80 </span><span class="lineCov">        258 :   Request(Request&amp;&amp; rhs)</span>
<span class="lineNum">      81 </span><span class="lineCov">        258 :       : unique_connection(std::move(rhs.unique_connection)),</span>
<span class="lineNum">      82 </span><span class="lineCov">        258 :         connection(*unique_connection.get()),</span>
<span class="lineNum">      83 </span><span class="lineCov">        258 :         http_data(unique_connection-&gt;HTTPRequest()),</span>
<span class="lineNum">      84 </span><span class="lineCov">        258 :         url(http_data.URL()),</span>
<span class="lineNum">      85 </span><span class="lineCov">        258 :         method(http_data.Method()),</span>
<span class="lineNum">      86 </span><span class="lineCov">        258 :         has_body(http_data.HasBody()),</span>
<span class="lineNum">      87 </span><span class="lineCov">       1548 :         body(has_body ? http_data.Body() : empty_string) {}</span>
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :   // A shortcut to allow `[](Request r) { r(&quot;OK&quot;); }` instead of `r.connection.SendHTTPResponse(&quot;OK&quot;)`.
<span class="lineNum">      90 </span>            :   // TODO(dkorolev): I could not make &lt;typename... ARGS&gt; work here. Investigate further?
<a name="91"><span class="lineNum">      91 </span>            :   // TODO(dkorolev): I could not make these calls support initializer lists. Investigate further?</a>
<span class="lineNum">      92 </span>            :   template &lt;typename T1&gt;
<span class="lineNum">      93 </span><span class="lineCov">         74 :   void operator()(T1&amp;&amp; p1) {</span>
<span class="lineNum">      94 </span><span class="lineCov">        148 :     connection.SendHTTPResponse(p1);</span>
<a name="95"><span class="lineNum">      95 </span><span class="lineCov">         74 :   }</span></a>
<span class="lineNum">      96 </span>            :   template &lt;typename T1, typename T2&gt;
<span class="lineNum">      97 </span><span class="lineCov">          4 :   void operator()(T1&amp;&amp; p1, T2&amp;&amp; p2) {</span>
<span class="lineNum">      98 </span><span class="lineCov">          4 :     connection.SendHTTPResponse(p1, p2);</span>
<span class="lineNum">      99 </span><span class="lineCov">          4 :   }</span>
<span class="lineNum">     100 </span>            :   template &lt;typename T1, typename T2, typename T3&gt;
<span class="lineNum">     101 </span>            :   void operator()(T1&amp;&amp; p1, T2&amp;&amp; p2, T3&amp;&amp; p3) {
<span class="lineNum">     102 </span>            :     connection.SendHTTPResponse(p1, p2, p3);
<a name="103"><span class="lineNum">     103 </span>            :   }</a>
<span class="lineNum">     104 </span>            :   template &lt;typename T1, typename T2, typename T3, typename T4&gt;
<span class="lineNum">     105 </span><span class="lineCov">         14 :   void operator()(T1&amp;&amp; p1, T2&amp;&amp; p2, T3&amp;&amp; p3, T4&amp;&amp; p4) {</span>
<span class="lineNum">     106 </span><span class="lineCov">         14 :     connection.SendHTTPResponse(p1, p2, p3, p4);</span>
<a name="107"><span class="lineNum">     107 </span><span class="lineCov">         14 :   }</span></a>
<span class="lineNum">     108 </span>            :   template &lt;typename T1, typename T2, typename T3, typename T4, typename T5&gt;
<span class="lineNum">     109 </span><span class="lineCov">          2 :   void operator()(T1&amp;&amp; p1, T2&amp;&amp; p2, T3&amp;&amp; p3, T4&amp;&amp; p4, T5&amp;&amp; p5) {</span>
<span class="lineNum">     110 </span><span class="lineCov">          2 :     connection.SendHTTPResponse(p1, p2, p3, p4, p5);</span>
<a name="111"><span class="lineNum">     111 </span><span class="lineCov">          2 :   }</span></a>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">          2 :   HTTPServerConnection::ChunkedResponseSender SendChunkedResponse() {</span>
<span class="lineNum">     114 </span><span class="lineCov">          4 :     return connection.SendChunkedHTTPResponse();</span>
<span class="lineNum">     115 </span>            :   }
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :   Request() = delete;
<span class="lineNum">     118 </span>            :   Request(const Request&amp;) = delete;
<span class="lineNum">     119 </span>            :   void operator=(const Request&amp;) = delete;
<span class="lineNum">     120 </span>            :   void operator=(Request&amp;&amp;) = delete;
<span class="lineNum">     121 </span>            : };
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : // HTTP server bound to a specific port.
<span class="lineNum">     124 </span>            : class HTTPServerPOSIX final {
<span class="lineNum">     125 </span>            :  public:
<span class="lineNum">     126 </span>            :   // The constructor starts listening on the specified port.
<a name="127"><span class="lineNum">     127 </span>            :   // Since instances of `HTTPServerPOSIX` are created via a singleton,</a>
<span class="lineNum">     128 </span>            :   // a listening thread will only be created once per port, on the first access to that port.
<span class="lineNum">     129 </span><span class="lineCov">          2 :   explicit HTTPServerPOSIX(int port)</span>
<span class="lineNum">     130 </span><span class="lineCov">          2 :       : terminating_(false), port_(port), thread_(&amp;HTTPServerPOSIX::Thread, this, Socket(port)) {}</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :   // The destructor closes the socket.
<a name="133"><span class="lineNum">     133 </span>            :   // Note that the destructor will only be run on the shutdown of the binary,</a>
<span class="lineNum">     134 </span>            :   // unregistering all handlers will still keep the listening thread up, and it will serve 404-s.
<span class="lineNum">     135 </span><span class="lineCov">          4 :   ~HTTPServerPOSIX() {</span>
<span class="lineNum">     136 </span><span class="lineCov">          2 :     terminating_ = true;</span>
<span class="lineNum">     137 </span>            :     // Notify the server thread that it should terminate.
<span class="lineNum">     138 </span>            :     // Effectively, call `HTTP(GET(&quot;/healthz&quot;))`, but in a way that avoids client &lt;=&gt; server dependency.
<span class="lineNum">     139 </span>            :     // LCOV_EXCL_START
<span class="lineNum">     140 </span>            :     try {
<span class="lineNum">     141 </span>            :       // TODO(dkorolev): This should always use the POSIX implemenation of the client, nothing fancier.
<span class="lineNum">     142 </span>            :       // It is a safe call, since the server itself is POSIX, so the architecture we are on is POSIX-friendly.
<span class="lineNum">     143 </span>            :       Connection(ClientSocket(&quot;localhost&quot;, port_)).BlockingWrite(&quot;GET /healthz HTTP/1.1\r\n\r\n&quot;).SendEOF();
<span class="lineNum">     144 </span>            :     } catch (const bricks::Exception&amp;) {
<span class="lineNum">     145 </span>            :       // It is guaranteed that after `terminated_` is set the server will be terminated on the next request,
<span class="lineNum">     146 </span>            :       // but it might so happen that that terminating request will happen between `terminating_ = true`
<span class="lineNum">     147 </span>            :       // and the consecutive request. Which is perfectly fine, since it implies that the server has terminated.
<span class="lineNum">     148 </span>            :     }
<span class="lineNum">     149 </span>            :     // LCOV_EXCL_STOP
<span class="lineNum">     150 </span>            :     // Wait for the thread to terminate.
<span class="lineNum">     151 </span><span class="lineCov">          2 :     if (thread_.joinable()) {</span>
<span class="lineNum">     152 </span><span class="lineCov">          2 :       thread_.join();</span>
<span class="lineNum">     153 </span>            :     }
<span class="lineNum">     154 </span><span class="lineCov">          2 :   }</span>
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            :   // The bare `Join()` method is only used by small scripts to run the server indefinitely,
<span class="lineNum">     157 </span>            :   // instead of `while(true)`
<span class="lineNum">     158 </span>            :   // LCOV_EXCL_START
<span class="lineNum">     159 </span>            :   void Join() {
<span class="lineNum">     160 </span>            :     thread_.join();  // May throw.
<span class="lineNum">     161 </span>            :   }
<span class="lineNum">     162 </span>            :   // LCOV_EXCL_STOP
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   // The philosophy of Register(path, handler):
<span class="lineNum">     165 </span>            :   // * Pass `handler` by value to make its copy.
<span class="lineNum">     166 </span>            :   //   This is done for lambdas and std::function&lt;&gt;-s.
<span class="lineNum">     167 </span>            :   //   The lifetime of a copy is thus governed by the API.
<span class="lineNum">     168 </span>            :   // * Pass `handler` by pointer to use the handler via pointer.
<span class="lineNum">     169 </span>            :   //   This allows using passed in objects without making a copy of them.
<span class="lineNum">     170 </span>            :   //   The lifetime of the object is then up to the user.
<a name="171"><span class="lineNum">     171 </span>            :   // Justification: `Register(&quot;/foo&quot;, InstanceOfFoo())` has no way of knowing for long should `InstanceOfFoo`</a>
<span class="lineNum">     172 </span>            :   // live.
<span class="lineNum">     173 </span><span class="lineCov">         74 :   void Register(const std::string&amp; path, std::function&lt;void(Request)&gt; handler) {</span>
<span class="lineNum">     174 </span><span class="lineCov">         74 :     std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span>
<span class="lineNum">     175 </span><span class="lineCov">         74 :     if (handlers_.find(path) != handlers_.end()) {</span>
<span class="lineNum">     176 </span><span class="lineCov">          4 :       BRICKS_THROW(HandlerAlreadyExistsException(path));</span>
<span class="lineNum">     177 </span>            :     }
<span class="lineNum">     178 </span><span class="lineCov">         74 :     handlers_[path] = handler;</span>
<a name="179"><span class="lineNum">     179 </span><span class="lineCov">         70 :   }</span></a>
<span class="lineNum">     180 </span>            :   template &lt;typename F&gt;
<span class="lineNum">     181 </span><span class="lineCov">         24 :   void Register(const std::string&amp; path, F* ptr_to_handler) {</span>
<span class="lineNum">     182 </span>            :     // TODO(dkorolev): Add a scoped version of registerers.
<span class="lineNum">     183 </span><span class="lineCov">         24 :     std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span>
<span class="lineNum">     184 </span><span class="lineCov">         24 :     if (handlers_.find(path) != handlers_.end()) {</span>
<a name="185"><span class="lineNum">     185 </span><span class="lineCov">          4 :       BRICKS_THROW(HandlerAlreadyExistsException(path));</span></a>
<span class="lineNum">     186 </span>            :     }
<span class="lineNum">     187 </span><span class="lineCov">         46 :     handlers_[path] = [ptr_to_handler](Request request) { (*ptr_to_handler)(std::move(request)); };</span>
<a name="188"><span class="lineNum">     188 </span><span class="lineCov">         20 :   }</span></a>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineCov">          4 :   void UnRegister(const std::string&amp; path) {</span>
<span class="lineNum">     191 </span>            :     // TODO(dkorolev): Add a scoped version of registerers.
<span class="lineNum">     192 </span><span class="lineCov">          4 :     std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span>
<span class="lineNum">     193 </span><span class="lineCov">          4 :     if (handlers_.find(path) == handlers_.end()) {</span>
<span class="lineNum">     194 </span><span class="lineCov">          2 :       BRICKS_THROW(HandlerDoesNotExistException(path));</span>
<span class="lineNum">     195 </span>            :     }
<span class="lineNum">     196 </span><span class="lineCov">          4 :     handlers_.erase(path);</span>
<span class="lineNum">     197 </span><span class="lineCov">          2 :   }</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :   struct StaticFileServer {
<a name="200"><span class="lineNum">     200 </span>            :     std::string body;</a>
<span class="lineNum">     201 </span>            :     std::string content_type;
<a name="202"><span class="lineNum">     202 </span><span class="lineCov">          6 :     explicit StaticFileServer(const std::string&amp; body, const std::string&amp; content_type)</span></a>
<span class="lineNum">     203 </span><span class="lineCov">          6 :         : body(body), content_type(content_type) {}</span>
<span class="lineNum">     204 </span><span class="lineCov">         12 :     void operator()(Request r) {</span>
<span class="lineNum">     205 </span><span class="lineCov">         12 :       if (r.method == &quot;GET&quot;) {</span>
<span class="lineNum">     206 </span><span class="lineCov">          8 :         r.connection.SendHTTPResponse(body, HTTPResponseCode.OK, content_type);</span>
<span class="lineNum">     207 </span>            :       } else {
<span class="lineNum">     208 </span>            :         r.connection.SendHTTPResponse(
<span class="lineNum">     209 </span><span class="lineCov">          4 :             DefaultMethodNotAllowedMessage(), HTTPResponseCode.MethodNotAllowed, &quot;text/plain&quot;);</span>
<span class="lineNum">     210 </span>            :       }
<span class="lineNum">     211 </span><span class="lineCov">         12 :     }</span>
<a name="212"><span class="lineNum">     212 </span>            :   };</a>
<span class="lineNum">     213 </span>            : 
<a name="214"><span class="lineNum">     214 </span><span class="lineCov">          4 :   void ServeStaticFilesFrom(const std::string&amp; dir, const std::string&amp; route_prefix = &quot;/&quot;) {</span></a>
<span class="lineNum">     215 </span>            :     // TODO(dkorolev): Add a scoped version of registerers.
<span class="lineNum">     216 </span><span class="lineCov">          8 :     FileSystem::ScanDir(dir, [this, &amp;dir, &amp;route_prefix](const std::string&amp; file) {</span>
<span class="lineNum">     217 </span><span class="lineCov">          8 :       const std::string content_type(GetFileMimeType(file, &quot;&quot;));</span>
<span class="lineNum">     218 </span><span class="lineCov">          8 :       if (!content_type.empty()) {</span>
<span class="lineNum">     219 </span>            :         // TODO(dkorolev): Wrap keeping file contents into a singleton
<span class="lineNum">     220 </span>            :         // that keeps a map from a (SHA256) hash to the contents.
<span class="lineNum">     221 </span>            :         Register(
<span class="lineNum">     222 </span><span class="lineCov">         12 :             route_prefix + file,</span>
<span class="lineNum">     223 </span><span class="lineCov">         18 :             new StaticFileServer(FileSystem::ReadFileAsString(FileSystem::JoinPath(dir, file)), content_type));</span>
<span class="lineNum">     224 </span>            :       } else {
<span class="lineNum">     225 </span><span class="lineCov">          2 :         BRICKS_THROW(CannotServeStaticFilesOfUnknownMIMEType(file));</span>
<span class="lineNum">     226 </span>            :       }
<span class="lineNum">     227 </span><span class="lineCov">         14 :     });</span>
<a name="228"><span class="lineNum">     228 </span><span class="lineCov">          2 :   }</span></a>
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span><span class="lineCov">         76 :   void ResetAllHandlers() {</span>
<span class="lineNum">     231 </span><span class="lineCov">         76 :     std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span>
<span class="lineNum">     232 </span><span class="lineCov">         76 :     handlers_.clear();</span>
<a name="233"><span class="lineNum">     233 </span><span class="lineCov">         76 :   }</span></a>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineCov">         10 :   size_t HandlersCount() const {</span>
<span class="lineNum">     236 </span><span class="lineCov">         10 :     std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span>
<span class="lineNum">     237 </span><span class="lineCov">         10 :     return handlers_.size();</span>
<span class="lineNum">     238 </span>            :   }
<a name="239"><span class="lineNum">     239 </span>            : </a>
<span class="lineNum">     240 </span>            :  private:
<span class="lineNum">     241 </span><span class="lineCov">          2 :   void Thread(Socket socket) {</span>
<span class="lineNum">     242 </span>            :     // TODO(dkorolev): Benchmark QPS.
<span class="lineNum">     243 </span><span class="lineCov">        132 :     while (!terminating_) {</span>
<span class="lineNum">     244 </span>            :       try {
<span class="lineNum">     245 </span><span class="lineCov">        130 :         std::unique_ptr&lt;HTTPServerConnection&gt; connection(new HTTPServerConnection(socket.Accept()));</span>
<span class="lineNum">     246 </span><span class="lineCov">        130 :         if (terminating_) {</span>
<span class="lineNum">     247 </span><span class="lineCov">          2 :           break;</span>
<span class="lineNum">     248 </span>            :         }
<span class="lineNum">     249 </span><span class="lineCov">        256 :         std::function&lt;void(Request)&gt; handler;</span>
<span class="lineNum">     250 </span>            :         {
<span class="lineNum">     251 </span>            :           // TODO(dkorolev): Read-write lock for performance?
<span class="lineNum">     252 </span><span class="lineCov">        128 :           std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span>
<span class="lineNum">     253 </span><span class="lineCov">        128 :           const auto cit = handlers_.find(connection-&gt;HTTPRequest().URL().path);</span>
<span class="lineNum">     254 </span><span class="lineCov">        128 :           if (cit != handlers_.end()) {</span>
<span class="lineNum">     255 </span><span class="lineCov">        116 :             handler = cit-&gt;second;</span>
<span class="lineNum">     256 </span><span class="lineCov">        128 :           }</span>
<span class="lineNum">     257 </span>            :         }
<span class="lineNum">     258 </span><span class="lineCov">        128 :         if (handler) {</span>
<span class="lineNum">     259 </span>            :           // OK, here's the tricky part with error handling and exceptions in this multithreaded world.
<span class="lineNum">     260 </span>            :           // * On the one hand, connection should be std::move-d into the request,
<span class="lineNum">     261 </span>            :           //   since it might end up being served in another thread, via a message queue, etc..
<span class="lineNum">     262 </span>            :           //   Thus, the user code is responsible for closing the connection.
<span class="lineNum">     263 </span>            :           //   Not to mention that the std::move-d away connection can easily outlive this scope.
<span class="lineNum">     264 </span>            :           // * On the other hand, if an exception occurs in user code, we need to return a 500,
<span class="lineNum">     265 </span>            :           //   which should obviously happen before the connection object is destructed.
<span class="lineNum">     266 </span>            :           //   This seems like a good reason to not std::move it away, or move it away with some flag,
<span class="lineNum">     267 </span>            :           //   but I thought hard of it, and don't think it's a good choice -- D.K.
<span class="lineNum">     268 </span>            :           //
<span class="lineNum">     269 </span>            :           // Solution: Do nothing here. No matter how tempting it is, it won't work across threads. Period.
<span class="lineNum">     270 </span>            :           //
<span class="lineNum">     271 </span>            :           // The implementation of HTTP connection will return an &quot;INTERNAL SERVER ERROR&quot;
<span class="lineNum">     272 </span>            :           // if no response was sent. That's what the user gets. In debugger, they can put a breakpoint there
<span class="lineNum">     273 </span>            :           // and see what caused the error.
<span class="lineNum">     274 </span>            :           //
<span class="lineNum">     275 </span>            :           // It is the job of the user of this library to ensure no exceptions leave their code.
<span class="lineNum">     276 </span>            :           //
<span class="lineNum">     277 </span>            :           // In practice, a top-level try-catch for `const bricks::Exception&amp; e`,
<span class="lineNum">     278 </span>            :           // or even `const std::exception&amp; e`, with logging of `e.what()` is a good enough solution.
<span class="lineNum">     279 </span>            :           try {
<span class="lineNum">     280 </span><span class="lineCov">        116 :             handler(Request(std::move(connection)));</span>
<span class="lineNum">     281 </span>            :           } catch (const std::exception&amp; e) {  // LCOV_EXCL_LINE
<span class="lineNum">     282 </span>            :             // WARNING: This `catch` is really not sufficient, it just logs a message
<span class="lineNum">     283 </span>            :             // if a user exception occurred in the same thread that ran the handler.
<span class="lineNum">     284 </span>            :             // DO NOT COUNT ON IT.
<span class="lineNum">     285 </span>            :             std::cerr &lt;&lt; &quot;HTTP route failed in user code: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;  // LCOV_EXCL_LINE
<span class="lineNum">     286 </span>            :           }
<span class="lineNum">     287 </span>            :         } else {
<span class="lineNum">     288 </span><span class="lineCov">         12 :           connection-&gt;SendHTTPResponse(DefaultFourOhFourMessage(), HTTPResponseCode.NotFound);</span>
<span class="lineNum">     289 </span><span class="lineCov">        128 :         }</span>
<span class="lineNum">     290 </span>            :       } catch (const std::exception&amp; e) {  // LCOV_EXCL_LINE
<span class="lineNum">     291 </span>            :         // TODO(dkorolev): More reliable logging.
<span class="lineNum">     292 </span>            :         std::cerr &lt;&lt; &quot;HTTP route failed: &quot; &lt;&lt; e.what() &lt;&lt; &quot;\n&quot;;  // LCOV_EXCL_LINE
<span class="lineNum">     293 </span>            :       }
<span class="lineNum">     294 </span>            :     }
<span class="lineNum">     295 </span><span class="lineCov">          2 :   }</span>
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :   HTTPServerPOSIX() = delete;
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   std::atomic_bool terminating_;
<span class="lineNum">     300 </span>            :   const int port_;
<span class="lineNum">     301 </span>            :   std::thread thread_;
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            :   // TODO(dkorolev): Look into read-write mutexes here.
<span class="lineNum">     304 </span>            :   mutable std::mutex mutex_;
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            :   std::map&lt;std::string, std::function&lt;void(Request)&gt;&gt; handlers_;
<span class="lineNum">     307 </span>            : };
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : }  // namespace api
<span class="lineNum">     310 </span>            : }  // namespace net
<span class="lineNum">     311 </span>            : }  // namespace bricks
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : using bricks::net::api::Request;
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            : #endif  // BRICKS_NET_API_POSIX_SERVER_H
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.11</a></td></tr>
  </table>
  <br>

</body>
</html>
