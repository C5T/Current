# Bricks

HTTP server and client, JSON and binary serialization, visualization and other core pieces to be reused across [`Current`](https://github.com/C5T/) projects.

![](https://raw.githubusercontent.com/C5T/Current/master/Bricks/holy_bricks.jpg)

<sub>Image credit: [Bender from Futurama](http://en.wikipedia.org/wiki/Bender_(Futurama)). Found via Bing image search.</sub>

<sub>The following documentation has been auto-generated from source code by means of a [`gen-docu.sh`](https://github.com/C5T/Current/blob/master/scripts/gen-docu.sh) script. Do not edit this file.</sub>
# Release Notes

* *3/4/2015* : **1.0, Initial public release.**

  [Documentation](https://github.com/C5T/Current/tree/v1.0#documentation),
  [tar.gz](https://github.com/C5T/Current/archive/v1.0.tar.gz),
  [zip](https://github.com/C5T/Current/archive/v1.0.zip).

  HTTP server and client API-s, [Cereal](http://uscilab.github.io/cereal/) for binary and JSON serialization, [gnuplot](http://www.gnuplot.info/) and [plotutils](http://www.gnu.org/software/plotutils/) ports, file system and string manipulation methods, a command line flags parsing tool and a header-only port of [GoogleTest](http://code.google.com/p/googletest/).

  Cross-platform, tested on Linux, Mac and Windows. 100% unit tested.

  Header-only C++11 with no external library dependencies.

# Documentation
## Cerealize

Bricks uses [**Cereal**](http://uscilab.github.io/cereal/) for JSON and Binary serialization of C++ objects:

* [Cereal Website](http://uscilab.github.io/cereal/): Cereal is a header-only C++11 serialization library.
* [Cereal GitHub](https://github.com/USCiLab/cereal): A C++11 library for serialization.

<sub>Personal thanks for a well-designed C++11 serialization library! â€” @dkorolev</sub>

The [`#include "Bricks/cerealize/cerealize.h"`](https://github.com/C5T/Current/blob/master/Bricks/cerealize/cerealize.h) header makes the below code snippets complete.
```cpp
// Add a `serialize()` method to make a C++ structure "cerealizable".
struct SimpleType {
  int number;
  std::string string;
  std::vector<int> vector_int;
  std::map<int, std::string> map_int_string;
  template <typename A> void serialize(A& ar) {
    // Use `CEREAL_NVP(member)` to keep member names when using JSON.
    ar(CEREAL_NVP(number),
       CEREAL_NVP(string),
       CEREAL_NVP(vector_int),
       CEREAL_NVP(map_int_string));
  }
};
```
```cpp
// Use `CerealizeJSON()` and `CerealizeParseJSON()` to create and parse JSON-s.
SimpleType x;
x.number = 42;
x.string = "test passed";
x.vector_int.push_back(1);
x.vector_int.push_back(2);
x.vector_int.push_back(3);
x.map_int_string[1] = "one";
x.map_int_string[42] = "the question";

// `CerealizeJSON(object)` converts a cerealize-able object into a JSON string.
const std::string json = CerealizeJSON(x);

// `CerealizeParseJSON<T>(json)` creates an instance of T from a JSON.
const SimpleType y = CerealizeParseJSON<SimpleType>(json);

// `CerealizeParseJSON(json, T& out)` allows omitting the type.
SimpleType z;
CerealizeParseJSON(json, z);
```
```cpp
// Use `load()/save()` instead of `serialize()` to customize serialization.
struct LoadSaveType {
  int a;
  int b;
  int sum;

  template <typename A> void save(A& ar) const {
    ar(CEREAL_NVP(a), CEREAL_NVP(b));
  }

  template <typename A> void load(A& ar) {
    ar(CEREAL_NVP(a), CEREAL_NVP(b));
    sum = a + b;
  }
};

LoadSaveType x;
x.a = 2;
x.b = 3;
EXPECT_EQ(5, CerealizeParseJSON<LoadSaveType>(CerealizeJSON(x)).sum);
```
```cpp
// The example below uses `Printf()`, include it.
#include "strings/printf.h"
using bricks::strings::Printf;
 
// Polymorphic types are supported with some caution.
struct ExamplePolymorphicType {
  std::string base;
  explicit ExamplePolymorphicType(const std::string& base = "") : base(base) {}

  virtual std::string AsString() const = 0;
  template <typename A> void serialize(A& ar) {
    ar(CEREAL_NVP(base));
  }
};

struct ExamplePolymorphicInt : ExamplePolymorphicType {
  int i;
  explicit ExamplePolymorphicInt(int i = 0)
      : ExamplePolymorphicType("int"), i(i) {}

  virtual std::string AsString() const override {
    return Printf("%s, %d", base.c_str(), i);
  }

  template <typename A> void serialize(A& ar) {
    ExamplePolymorphicType::serialize(ar);
    ar(CEREAL_NVP(i));
  }
};
// Need to register the derived type.
CEREAL_REGISTER_TYPE(ExamplePolymorphicInt);

struct ExamplePolymorphicDouble : ExamplePolymorphicType {
  double d;
  explicit ExamplePolymorphicDouble(double d = 0)
      : ExamplePolymorphicType("double"), d(d) {}

  virtual std::string AsString() const override {
    return Printf("%s, %lf", base.c_str(), d);
  }

  template <typename A> void serialize(A& ar) {
    ExamplePolymorphicType::serialize(ar);
    ar(CEREAL_NVP(d));
  }
};
// Need to register the derived type.
CEREAL_REGISTER_TYPE(ExamplePolymorphicDouble);

const std::string json_int =
  CerealizeJSON(WithBaseType<ExamplePolymorphicType>(ExamplePolymorphicInt(42)));

const std::string json_double =
  CerealizeJSON(WithBaseType<ExamplePolymorphicType>(ExamplePolymorphicDouble(M_PI)));

EXPECT_EQ("int, 42",
          CerealizeParseJSON<std::unique_ptr<ExamplePolymorphicType>>(json_int)->AsString());

EXPECT_EQ("double, 3.141593",
          CerealizeParseJSON<std::unique_ptr<ExamplePolymorphicType>>(json_double)->AsString());
```
## Visualization Library

Bricks has C++ bindings for [`gnuplot`](http://www.gnuplot.info/), [`#include "Bricks/graph/gnuplot.h"`](https://github.com/Current/C5T/blob/master/Bricks/graph/gnuplot.h) to use it.

External [`gnuplot`](http://www.gnuplot.info/) binary is invoked. The requirement is that it should be installed in the system and accessible in the `$PATH`.
```cpp
// Where visualization meets love.
using namespace bricks::gnuplot;
const size_t image_dim = 800;
const std::string result = GNUPlot()
  .Title("Imagine all the people ...")
  .NoKey()
  .Grid("back")
  .XLabel("... living life in peace")
  .YLabel("John Lennon, \"Imagine\"")
  .Plot(WithMeta([](Plotter p) {
    const size_t N = 1000;
    for (size_t i = 0; i < N; ++i) {
      const double t = M_PI * 2 * i / (N - 1);
      p(16 * pow(sin(t), 3),
        -(13 * cos(t) + 5 * cos(t * 2) - 2 * cos(t * 3) - cos(t * 4)));
    }
  }).LineWidth(5).Color("rgb '#FF0080'"))
  .ImageSize(image_dim)
  .OutputFormat("svg");  // Although the one below is actually a "png".
```
![](https://raw.githubusercontent.com/C5T/Current/master/Bricks/graph/golden/love-Linux.png)
```cpp
// Where visualization meets science.
using namespace bricks::gnuplot;
const size_t image_dim = 800;
const std::string result = GNUPlot()
  .Title("Graph 'title' with various \"quotes\"")
  .KeyTitle("'Legend', also known as the \"key\"")
  .XRange(-5, +5)
  .YRange(-2, +2)
  .Grid("back")
  .Plot([](Plotter& p) {
    for (int i = -50; i <= +50; ++i) {
      p(0.1 * i, ::sin(0.1 * i));
    }
  })
  .Plot(WithMeta([](Plotter& p) {
                   for (int i = -50; i <= +50; ++i) {
                     p(0.1 * i, ::cos(0.1 * i));
                   }
                 })
            .AsPoints()
            .Color("rgb 'blue'")
            .Name("\"cos(x)\", '.AsPoints().Color(\"rgb 'blue'\")'"))
  .ImageSize(image_dim)
  .OutputFormat("svg");  // Although the one below is actually a "png".
```
![](https://raw.githubusercontent.com/C5T/Current/master/Bricks/graph/golden/science-Linux.png)
```cpp
#include "../../strings/printf.h"

// Show labels on the plane.
using namespace bricks::gnuplot;
const size_t image_dim = 800;
const std::string result = GNUPlot()
  .Title("Labeled Points")
  .NoKey()
  .NoTics()
  .NoBorder()
  .Grid("back")
  .XRange(-1.5, +1.5)
  .YRange(-1.5, +1.5)
  .Plot(WithMeta([](Plotter& p) {
    const int N = 7;
    for (int i = 0; i < N; ++i) {
      const double phi = M_PI * 2 * i / N;
      p(cos(phi), sin(phi), bricks::strings::Printf("P%d", i));
    }
  }).AsLabels())
  .ImageSize(image_dim)
  .OutputFormat("svg");  // Although the one below is actually a "png".
```
![](https://raw.githubusercontent.com/C5T/Current/master/Bricks/graph/golden/labels-Linux.png)
## Functional Template Library

Bricks makes extensive use of C++11 variadic templates. A few generic methods are exposed as `bricks::metaprogramming`.
```cpp
// Map.
template<typename T> struct add_100 { enum { x = T::x + 100 }; };

struct A { enum { x = 1 }; };
struct B { enum { x = 2 }; };
struct C { enum { x = 3 }; };

typedef TypeList<A, B, C> TYPELIST_BEFORE;
static_assert(TypeListSize<TYPELIST_BEFORE>::value == 3, "");
static_assert(TypeListElement<0, TYPELIST_BEFORE>::x == 1, "");
static_assert(TypeListElement<1, TYPELIST_BEFORE>::x == 2, "");
static_assert(TypeListElement<2, TYPELIST_BEFORE>::x == 3, "");

typedef bricks::metaprogramming::map<add_100, TYPELIST_BEFORE> TYPELIST_AFTER;
static_assert(TypeListSize<TYPELIST_AFTER>::value == 3, "");
static_assert(TypeListElement<0, TYPELIST_AFTER>::x == 101, "");
static_assert(TypeListElement<1, TYPELIST_AFTER>::x == 102, "");
static_assert(TypeListElement<2, TYPELIST_AFTER>::x == 103, "");

// Filter.
template <typename T> struct y_is_even { enum { filter = ((T::y % 2) == 0) }; };

struct A { enum { y = 10 }; };
struct B { enum { y = 15 }; };
struct C { enum { y = 20 }; };
typedef TypeList<A, B, C> TYPELIST_BEFORE;
static_assert(TypeListSize<TYPELIST_BEFORE>::value == 3, "");
static_assert(TypeListElement<0, TYPELIST_BEFORE>::y == 10, "");
static_assert(TypeListElement<1, TYPELIST_BEFORE>::y == 15, "");
static_assert(TypeListElement<2, TYPELIST_BEFORE>::y == 20, "");

typedef bricks::metaprogramming::filter<y_is_even, TYPELIST_BEFORE> TYPELIST_AFTER;
static_assert(TypeListSize<TYPELIST_AFTER>::value == 2, "");
static_assert(TypeListElement<0, TYPELIST_AFTER>::y == 10, "");
static_assert(TypeListElement<1, TYPELIST_AFTER>::y == 20, "");
  
// Reduce.
template<typename A, typename B> struct concatenate_s {
  static std::string s() { return "(" + A::s() + "+" + B::s() + ")"; }
};
    
struct A { static std::string s() { return "A"; } };
struct B { static std::string s() { return "B"; } };
struct C { static std::string s() { return "C"; } };
EXPECT_EQ("(A+(B+C))", (bricks::metaprogramming::reduce<concatenate_s, TypeList<A, B, C>>::s()));
  
// Combine.
struct NEG {
  // A simple way to differentiate logic by struct/class type
  // is to use a helper local type as the 1st param in the signature.
  struct TYPE {};
  // `operator()` on an instance of a `combine`-d type
  // calls `operator()` of the type from the type list that matches
  // the types of parameters passed in.
  // If none or more than one of the input types have the matching signature,
  // attempting such a call will result in compilation error.
  int operator()(TYPE, int a) { return -a; }
  // `DispatchToAll()` on an instance of `combine`-d type
  // calls `DispatchToAll()` from all combined classes,
  // in the order they have been listed in the type list.
  template<typename T> void DispatchToAll(T& x) { x.result += "NEG\n"; }
};

struct ADD {
  struct TYPE {};
  int operator()(TYPE, int a, int b) { return a + b; }
  // Prove that the method is instantiated at compile time.
  template <typename T>
  int operator()(TYPE, int a, int b, T c) {
    return a + b + AsInt(c);
  }
  template<typename T> void DispatchToAll(T& x) { x.result += "ADD\n"; }
};

// Since "has-a" is used instead of "is-a",
// mutual inheritance of underlying types
// is not a problem at all.
// Confirm this by making `MUL` inherit from `ADD`.
struct MUL : ADD {
  struct TYPE {};
  int operator()(TYPE, int a, int b) { return a * b; }
  int operator()(TYPE, int a, int b, int c) { return a * b * c; }
  template<typename T> void DispatchToAll(T& x) { x.result += "MUL\n"; }
};
  
// User-friendly method names, internally dispatching calls via `operator()`.
// A good way to make sure new names appear in one place only, since
// using `using`-s would require writing them down at least twice each.
struct UserFriendlyArithmetics :
    bricks::metaprogramming::combine<TypeList<NEG, ADD, MUL>> {
  int Neg(int x) {
    return operator()(NEG::TYPE(), x);
  }
  template <typename... T>
  int Add(T... xs) {
    return operator()(ADD::TYPE(), xs...);
  }
  template <typename... T>
  int Mul(T... xs) {
    return operator()(MUL::TYPE(), xs...);
  }
  // The implementation for `Div()` is not provided,
  // yet the code will compile until it's attempted to be used.
  // (Unit tests and code coverage measurement FTW!)
  template <typename... T>
  int Div(T... xs) {
    struct TypeForWhichThereIsNoImplemenation {};
    return operator()(TypeForWhichThereIsNoImplemenation(),
                      xs...);
  }
};
EXPECT_EQ(1, NEG()(NEG::TYPE(), -1));
EXPECT_EQ(3, ADD()(ADD::TYPE(), 1, 2));
EXPECT_EQ(6, ADD()(ADD::TYPE(), 1, 2, "3"));
EXPECT_EQ(20, MUL()(MUL::TYPE(), 4, 5));
EXPECT_EQ(120, MUL()(MUL::TYPE(), 4, 5, 6));

// As a sanity check, since `MUL` inherits from `ADD`,
// the following construct will work just fine.
EXPECT_EQ(15, MUL().ADD::operator()(ADD::TYPE(), 7, 8));

typedef bricks::metaprogramming::combine<TypeList<NEG, ADD, MUL>> Arithmetics;
EXPECT_EQ(-1, Arithmetics()(NEG::TYPE(), 1));
EXPECT_EQ(5, Arithmetics()(ADD::TYPE(), 2, 3));
EXPECT_EQ(9, Arithmetics()(ADD::TYPE(), 2, 3, "4"));
EXPECT_EQ(30, Arithmetics()(MUL::TYPE(), 5, 6));
EXPECT_EQ(210, Arithmetics()(MUL::TYPE(), 5, 6, 7));

// Using the dispatched methods.
EXPECT_EQ(42, UserFriendlyArithmetics().Neg(-42));
EXPECT_EQ(21, UserFriendlyArithmetics().Add(10, 11));
EXPECT_EQ(33, UserFriendlyArithmetics().Add(10, 11, "12"));
EXPECT_EQ(420, UserFriendlyArithmetics().Mul(20, 21));
EXPECT_EQ(9240, UserFriendlyArithmetics().Mul(20, 21, 22));
  
// The following call will fail to compile,
// with a nice error message explaining
// that none of the `NEG`, `ADD` and `MUL`
// have division operation defined.
//
// UserFriendlyArithmetics().Div(100, 5);

struct Magic {
  std::string result;
};
Magic magic;
UserFriendlyArithmetics().DispatchToAll(magic);
EXPECT_EQ("NEG\nADD\nMUL\n", magic.result);

// RTTI.
struct BASE {
  // Need a virtual base.
  virtual ~BASE() = default;
};

struct A : virtual BASE {
  int a = 101;
  void foo(std::ostream& os) {
    a += 1000;
    os << "mutable a=" << a << std::endl;
  }
  void foo(std::ostream& os) const {
    os << "a=" << a << std::endl;
  }
};

// Inherit from `A` as well, just to show that we can.
struct B : virtual A, virtual BASE {
  int b = 102;
  void bar(std::ostream& os) const {
    os << "b=" << b << std::endl;
  }
};
// Even more "multiple" inheritance.
struct C : virtual A, virtual B, virtual BASE {
  int c = 103;
  void baz(std::ostream& os) const {
    os << "c=" << c << std::endl;
  }
};
A a;
B b;
C c;

const BASE& const_pa = a;
const BASE& const_pb = b;
const BASE& const_pc = c;

BASE& mutable_pa = a;
BASE& mutable_pb = b;

struct call_foo_bar {
  void operator()(const A& a) {
    a.foo(os);
  }
  void operator()(A& a) {
    // Mutable version.
    a.foo(os);
  }
  void operator()(const B& b) {
    b.bar(os);
  }
  std::ostringstream os;
} foo_bar;

RTTIDynamicCall<TypeList<A, B>>(const_pa, foo_bar);
RTTIDynamicCall<TypeList<A, B>>(const_pb, foo_bar);
EXPECT_EQ("a=101\nb=102\n", foo_bar.os.str());
RTTIDynamicCall<TypeList<A, B>>(mutable_pa, foo_bar);
RTTIDynamicCall<TypeList<A, B>>(mutable_pb, foo_bar);
EXPECT_EQ("a=101\nb=102\nmutable a=1101\nb=102\n", foo_bar.os.str());
RTTIDynamicCall<TypeList<A, B>>(const_pa, foo_bar);
RTTIDynamicCall<TypeList<A, B>>(const_pb, foo_bar);
EXPECT_EQ("a=101\nb=102\nmutable a=1101\nb=102\na=1101\nb=102\n", foo_bar.os.str());

struct call_bar_baz {
  void operator()(const B& b) {
    b.bar(os);
  }
  void operator()(const C& c) {
    c.baz(os);
  }
  std::ostringstream os;
} bar_baz;

RTTIDynamicCall<TypeList<B, C>>(const_pb, bar_baz);
RTTIDynamicCall<TypeList<B, C>>(const_pc, bar_baz);
EXPECT_EQ("b=102\nc=103\n", bar_baz.os.str());
struct call_foo_baz {
  void operator()(const A& a) {
    a.foo(os);
  }
  void operator()(A& a) {
    // Mutable version.
    a.foo(os);
  }
  void operator()(const C& c) {
    c.baz(os);
  }
  void operator()(const A& a, int x, const std::string& y) {
    a.foo(os);
    os << "[" << x << "]['" << y << "']\n";
  }
  void operator()(const C& c, int x, const std::string& y) {
    c.baz(os);
    os << "[" << x << "]['" << y << "']\n";
  }
  std::ostringstream os;
};

std::unique_ptr<BASE> unique_a(new A());
std::unique_ptr<BASE> unique_c(new C());
call_foo_baz foo_baz;
RTTIDynamicCall<TypeList<A, C>>(unique_a, foo_baz);
RTTIDynamicCall<TypeList<A, C>>(unique_c, foo_baz);
EXPECT_EQ("mutable a=1101\nc=103\n", foo_baz.os.str());
RTTIDynamicCall<TypeList<A, C>>(static_cast<const std::unique_ptr<BASE>&>(unique_a), foo_baz);
RTTIDynamicCall<TypeList<A, C>>(static_cast<const std::unique_ptr<BASE>&>(unique_c), foo_baz);
EXPECT_EQ("mutable a=1101\nc=103\na=1101\nc=103\n", foo_baz.os.str());
RTTIDynamicCall<TypeList<A, C>>(unique_a, foo_baz);
RTTIDynamicCall<TypeList<A, C>>(unique_c, foo_baz);
EXPECT_EQ("mutable a=1101\nc=103\na=1101\nc=103\nmutable a=2101\nc=103\n", foo_baz.os.str());

call_foo_baz foo_baz2;
RTTIDynamicCall<TypeList<A, C>>(unique_a, foo_baz2, 1, std::string("one"));
RTTIDynamicCall<TypeList<A, C>>(unique_c, foo_baz2, 2, std::string("two"));
EXPECT_EQ("a=2101\n[1]['one']\nc=103\n[2]['two']\n", foo_baz2.os.str());
```
## Run-Time Type Dispatching

Bricks can dispatch calls to the right implementation at runtime, with user code being free of virtual functions.

This comes especially handy when processing log entries from a large stream of data, where only a few types are of immediate interest.

Use the [`#include "Bricks/rtti/dispatcher.h"`](https://github.com/C5T/Current/blob/Bricks/master/rtti/dispatcher.h) header to run the code snippets below.

`TODO(dkorolev)` a wiser way for the end user to leverage the above is by means of `Sherlock` once it's checked in.
```cpp
// The example below uses `Printf()`, include it.
#include "strings/printf.h"
using bricks::strings::Printf;
 
struct ExampleBase {
  virtual ~ExampleBase() = default;
};

struct ExampleInt : ExampleBase {
  int i;
  explicit ExampleInt(int i) : i(i) {}
};

struct ExampleString : ExampleBase {
  std::string s;
  explicit ExampleString(const std::string& s) : s(s) {}
};

struct ExampleMoo : ExampleBase {
};

struct ExampleProcessor {
  std::string result;
  void operator()(const ExampleBase&) { result = "unknown"; }
  void operator()(const ExampleInt& x) { result = Printf("int %d", x.i); }
  void operator()(const ExampleString& x) { result = Printf("string '%s'", x.s.c_str()); }
  void operator()(const ExampleMoo&) { result = "moo!"; }
};

using bricks::rtti::RuntimeTupleDispatcher;
typedef RuntimeTupleDispatcher<ExampleBase,
                               tuple<ExampleInt, ExampleString, ExampleMoo>> Dispatcher;

ExampleProcessor processor;

Dispatcher::DispatchCall(ExampleBase(), processor);
EXPECT_EQ(processor.result, "unknown");

Dispatcher::DispatchCall(ExampleInt(42), processor);
EXPECT_EQ(processor.result, "int 42");

Dispatcher::DispatchCall(ExampleString("foo"), processor);
EXPECT_EQ(processor.result, "string 'foo'");

Dispatcher::DispatchCall(ExampleMoo(), processor);
EXPECT_EQ(processor.result, "moo!");
```
## Command Line Parsing: `dflags`

Bricks has [`dflags`](https://github.com/C5T/Current/blob/master/Bricks/dflags/dflags.h): a C++ library to parse command-line flags.

```cpp
DEFINE_int32(answer, 42, "Human-readable flag description.");
DEFINE_string(question, "six by nine", "Another human-readable flag description.");

void example() {
  std::cout << FLAGS_question.length() << ' ' << FLAGS_answer * FLAGS_answer << std::endl;
}

int main(int argc, char** argv) {
  ParseDFlags(&argc, &argv);
  // `google::ParseCommandLineFlags(&argc, &argv);`
  // is supported as well for compatibility reasons.
  example();
}
```

Supported types are `string` as `std::string`, `int32`, `uint32`, `int64`, `uint64`, `float`, `double` and `bool`. Booleans accept `0`/`1` and lowercase or capitalized `true`/`false`/`yes`/`no`.

Flags can be passed in as `-flag=value`, `--flag=value`, `-flag value` or `--flag value` parameters.

Undefined flag triggers an error message dumped into stderr followed by exit(-1).  Same happens if `ParseDFlags()` was called more than once.

Non-flag parameters are kept; ParseDFlags() replaces argc/argv with the new, updated values, eliminating the ones holding the parsed flags. In other words `./main foo --flag_bar=bar baz` results in new `argc == 2`, new `argv == { argv[0], "foo", "baz" }`.

Passing `--help` will cause `ParseDFlags()` to print all registered flags with their descriptions and `exit(0)`.

[`dflags`](https://github.com/KnowSheet/Bricks/blob/master/dflags/dflags.h) is a simplified header-only version of Google's [`gflags`](https://code.google.com/p/gflags/). It requires no linker dependencies and largely is backwards-compatible.
## Extras

[`Bricks`](https://github.com/C5T/Current/) contains several other useful bits, including cross-platform file system wrapper, string manipulation functions, in-memory message queue and system clock utilities.
