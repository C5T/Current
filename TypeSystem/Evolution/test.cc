/*******************************************************************************
The MIT License (MIT)

Copyright (c) 2016 Maxim Zhurovich <zhurovich@gmail.com>
          (c) 2016 Dmitry "Dima" Korolev <dmitry.korolev@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*******************************************************************************/

// This `test.cc` file is `#include`-d from `../test.cc`, and thus needs a header guard.

// The next line can be temporarily uncommented to simplify compiling the test and generating the golden schema.
// #define JUST_GENERATE_THAT_GOLDEN_FILE

#ifndef CURRENT_TYPE_SYSTEM_EVOLUTION_TEST_CC
#define CURRENT_TYPE_SYSTEM_EVOLUTION_TEST_CC

#define CURRENT_MOCK_TIME

#include "type_evolution.h"

#include "../struct.h"
#include "../variant.h"

#include "../Schema/schema.h"
#include "../Serialization/json.h"

#include "../../Storage/persister/sherlock.h"
#include "../../Storage/storage.h"

#include "../../Bricks/dflags/dflags.h"
#include "../../Bricks/file/file.h"

#include "../../3rdparty/gtest/gtest-main-with-dflags.h"

#ifndef CURRENT_WINDOWS
DEFINE_string(type_evolution_test_tmpdir, ".current", "Local path for the test to create temporary files in.");
#else
DEFINE_string(type_evolution_test_tmpdir, "Debug", "Local path for the test to create temporary files in.");
#endif

DEFINE_bool(write_type_evolution_golden_files, false, "Set to `true` to [over]write golden files.");

namespace type_evolution_test {

// The code mimicking what is autogenerated, to have the unit test run both ways,
// as well as to simplify development, as golden code can be written and tested prior to the autogenreated one.

///////////////////////////////////////////////////////////////////////////////////////////////////
// autogenerated code {
///////////////////////////////////////////////////////////////////////////////////////////////////

namespace current_user_namespace {
namespace SchemaV1 {

CURRENT_STRUCT(SimpleStruct) {
  CURRENT_FIELD(x, int32_t, 101);
  CURRENT_FIELD(y, int32_t, 102);
  CURRENT_FIELD(z, std::string, "foo");
  CURRENT_DEFAULT_CONSTRUCTOR(SimpleStruct) {}
};

CURRENT_STRUCT(StructWithStruct) {
  CURRENT_FIELD(s, SimpleStruct);
  CURRENT_DEFAULT_CONSTRUCTOR(StructWithStruct) {}
};

CURRENT_STRUCT(StructWithVector) {
  CURRENT_FIELD(numerical_ids, std::vector<int32_t>);
  CURRENT_DEFAULT_CONSTRUCTOR(StructWithVector) : numerical_ids({8, 50}) {}
};

// clang-format off
CURRENT_ENUM(EnumClassType, bool) {
  False = false,
  True = true
};
// clang-format on

CURRENT_STRUCT(OtherTypes) {
  CURRENT_FIELD(enum_class, EnumClassType, EnumClassType::False);
  CURRENT_FIELD(optional, Optional<std::string>);
  CURRENT_DEFAULT_CONSTRUCTOR(OtherTypes) {}
};

CURRENT_STRUCT(StructWithVariant) {
  CURRENT_FIELD(v, (Variant<SimpleStruct, StructWithStruct, OtherTypes>));
  CURRENT_DEFAULT_CONSTRUCTOR(StructWithVariant) {}
};

CURRENT_STRUCT(Name) {
  CURRENT_FIELD(first, std::string, "Karl");
  CURRENT_FIELD(last, std::string, "Marx");
  CURRENT_DEFAULT_CONSTRUCTOR(Name) {}
  CURRENT_CONSTRUCTOR(Name)(const std::string& first, const std::string& last) : first(first), last(last) {}
};

CURRENT_STRUCT(StructWithVectorOfNames) {
  CURRENT_FIELD(w, std::vector<Name>);
  CURRENT_DEFAULT_CONSTRUCTOR(StructWithVectorOfNames) {}
};

}  // namespacetype_evolution_test:: current_user_namespace::SchemaV1
}  // namespace type_evolution_test::current_user_namespace

CURRENT_NAMESPACE(SchemaV1) {
  CURRENT_NAMESPACE_TYPE(SimpleStruct, current_user_namespace::SchemaV1::SimpleStruct);
  CURRENT_NAMESPACE_TYPE(StructWithStruct, current_user_namespace::SchemaV1::StructWithStruct);
  CURRENT_NAMESPACE_TYPE(StructWithVector, current_user_namespace::SchemaV1::StructWithVector);
  CURRENT_NAMESPACE_TYPE(EnumClassType, current_user_namespace::SchemaV1::EnumClassType);
  CURRENT_NAMESPACE_TYPE(OtherTypes, current_user_namespace::SchemaV1::OtherTypes);
  CURRENT_NAMESPACE_TYPE(StructWithVariant, current_user_namespace::SchemaV1::StructWithVariant);
  CURRENT_NAMESPACE_TYPE(Name, current_user_namespace::SchemaV1::Name);
  CURRENT_NAMESPACE_TYPE(StructWithVectorOfNames, current_user_namespace::SchemaV1::StructWithVectorOfNames);
};

}  // namespace type_evolution_test

namespace current {
namespace type_evolution {

// Default evolution for `SimpleStruct`.
template <typename EVOLVER>
struct Evolve<type_evolution_test::SchemaV1, type_evolution_test::SchemaV1::SimpleStruct, EVOLVER> {
  template <typename INTO>
  static void Go(const typename type_evolution_test::SchemaV1::SimpleStruct& from, typename INTO::SimpleStruct& into) {
    static_assert(reflection::TotalFieldCounter<typename type_evolution_test::SchemaV1::SimpleStruct>::value ==
                      reflection::TotalFieldCounter<typename INTO::SimpleStruct>::value,
                  "Total field count for `SimpleStruct` must match.");
    Evolve<type_evolution_test::SchemaV1, decltype(from.x), EVOLVER>::template Go<INTO>(from.x, into.x);
    Evolve<type_evolution_test::SchemaV1, decltype(from.y), EVOLVER>::template Go<INTO>(from.y, into.y);
    Evolve<type_evolution_test::SchemaV1, decltype(from.z), EVOLVER>::template Go<INTO>(from.z, into.z);
  }
};

// Default evolution for `StructWithStruct`.
template <typename EVOLVER>
struct Evolve<type_evolution_test::SchemaV1, type_evolution_test::SchemaV1::StructWithStruct, EVOLVER> {
  template <typename INTO>
  static void Go(const typename type_evolution_test::SchemaV1::StructWithStruct& from,
                 typename INTO::StructWithStruct& into) {
    static_assert(reflection::TotalFieldCounter<typename type_evolution_test::SchemaV1::StructWithStruct>::value ==
                      reflection::TotalFieldCounter<typename INTO::StructWithStruct>::value,
                  "Total field count for `StructWithStruct` must match.");
    Evolve<type_evolution_test::SchemaV1, decltype(from.s), EVOLVER>::template Go<INTO>(from.s, into.s);
  }
};

// Default evolution for `StructWithVector`.
// It won't compile if attempted to be used to evolve `SchemaV1` into `SchemaV2`,
// since that would attemmpt to cast `std::string` into `int32_t`.
template <typename EVOLVER>
struct Evolve<type_evolution_test::SchemaV1, type_evolution_test::SchemaV1::StructWithVector, EVOLVER> {
  template <typename INTO>
  static void Go(const typename type_evolution_test::SchemaV1::StructWithVector& from,
                 typename INTO::StructWithVector& into) {
    static_assert(reflection::TotalFieldCounter<typename type_evolution_test::SchemaV1::StructWithVector>::value ==
                      reflection::TotalFieldCounter<typename INTO::StructWithVector>::value,
                  "Total field count for `StructWithVector` must match.");
    into.numerical_ids.clear();
    into.numerical_ids.reserve(from.numerical_ids.size());
    for (const auto& cit : from.numerical_ids) {
      into.numerical_ids.push_back(Evolve<type_evolution_test::SchemaV1,
                                          typename decltype(from.numerical_ids)::value_type,
                                          EVOLVER>::template Go<INTO>(cit));
    }
  }
};

// Default evolution for `CURRENT_ENUM(EnumClassType)`.
template <typename NAMESPACE, typename EVOLVER>
struct Evolve<NAMESPACE, typename type_evolution_test::SchemaV1::EnumClassType, EVOLVER> {
  template <typename INTO>
  static void Go(typename type_evolution_test::SchemaV1::EnumClassType from, typename INTO::EnumClassType& into) {
    into = static_cast<typename INTO::EnumClassType>(from);
  }
};

// Default evolution for `OtherTypes`.
template <typename EVOLVER>
struct Evolve<type_evolution_test::SchemaV1, type_evolution_test::SchemaV1::OtherTypes, EVOLVER> {
  template <typename INTO>
  static void Go(const typename type_evolution_test::SchemaV1::OtherTypes& from, typename INTO::OtherTypes& into) {
    static_assert(reflection::TotalFieldCounter<typename type_evolution_test::SchemaV1::OtherTypes>::value ==
                      reflection::TotalFieldCounter<typename INTO::OtherTypes>::value,
                  "Total field count for `OtherTypes` must match.");
    Evolve<type_evolution_test::SchemaV1, decltype(from.enum_class), EVOLVER>::template Go<INTO>(from.enum_class,
                                                                                                 into.enum_class);
    Evolve<type_evolution_test::SchemaV1, decltype(from.optional), EVOLVER>::template Go<INTO>(from.optional,
                                                                                               into.optional);
  }
};

// Default evolution for `StructWithVariant`. Must auto-generate all `Variant<>` cases too.
template <typename DESTINATION_VARIANT, typename FROM_NAMESPACE, typename INTO, typename EVOLVER>
struct CustomVariantTypedEvolver {
  DESTINATION_VARIANT& into;
  explicit CustomVariantTypedEvolver(DESTINATION_VARIANT& into) : into(into) {}
  void operator()(const typename FROM_NAMESPACE::SimpleStruct& value) {
    using into_t = typename INTO::SimpleStruct;
    into = into_t();
    Evolve<FROM_NAMESPACE, typename FROM_NAMESPACE::SimpleStruct, EVOLVER>::template Go<INTO>(value,
                                                                                              Value<into_t>(into));
  }
  void operator()(const typename FROM_NAMESPACE::StructWithStruct& value) {
    using into_t = typename INTO::StructWithStruct;
    into = into_t();
    Evolve<FROM_NAMESPACE, typename FROM_NAMESPACE::StructWithStruct, EVOLVER>::template Go<INTO>(value,
                                                                                                  Value<into_t>(into));
  }
  void operator()(const typename FROM_NAMESPACE::OtherTypes& value) {
    using into_t = typename INTO::OtherTypes;
    into = into_t();
    Evolve<FROM_NAMESPACE, typename FROM_NAMESPACE::OtherTypes, EVOLVER>::template Go<INTO>(value, Value<into_t>(into));
  }
};

template <typename EVOLVER>
struct Evolve<type_evolution_test::SchemaV1,
              Variant<type_evolution_test::SchemaV1::SimpleStruct,
                      type_evolution_test::SchemaV1::StructWithStruct,
                      type_evolution_test::SchemaV1::OtherTypes>,
              EVOLVER> {
  template <typename INTO, typename INTO_VARIANT_TYPE>
  static void Go(const Variant<type_evolution_test::SchemaV1::SimpleStruct,
                               type_evolution_test::SchemaV1::StructWithStruct,
                               type_evolution_test::SchemaV1::OtherTypes>& from,
                 INTO_VARIANT_TYPE& into) {
    {
      CustomVariantTypedEvolver<decltype(into), type_evolution_test::SchemaV1, INTO, EVOLVER> logic(into);
      from.Call(logic);
    }
  }
};

template <typename EVOLVER>
struct Evolve<type_evolution_test::SchemaV1, type_evolution_test::SchemaV1::StructWithVariant, EVOLVER> {
  template <typename INTO>
  static void Go(const typename type_evolution_test::SchemaV1::StructWithVariant& from,
                 typename INTO::StructWithVariant& into) {
    static_assert(reflection::TotalFieldCounter<typename type_evolution_test::SchemaV1::StructWithVariant>::value ==
                      reflection::TotalFieldCounter<typename INTO::StructWithVariant>::value,
                  "Total field count for `StructWithVariant` must match.");
    Evolve<type_evolution_test::SchemaV1, decltype(from.v), EVOLVER>::template Go<INTO>(from.v, into.v);
  }
};

// Default evolution for `Name`.
// It won't compile if attempted to be used to evolve `SchemaV1` into `SchemaV2`, as
// the number and the set of fields in `SchemaV2::Name` is different from `SchemaV1::Name`.
template <typename EVOLVER>
struct Evolve<type_evolution_test::SchemaV1, type_evolution_test::SchemaV1::Name, EVOLVER> {
  template <typename INTO>
  static void Go(const typename type_evolution_test::SchemaV1::Name& from, typename INTO::Name& into) {
    static_assert(reflection::TotalFieldCounter<typename type_evolution_test::SchemaV1::Name>::value ==
                      reflection::TotalFieldCounter<typename INTO::Name>::value,
                  "Total field count for `Name` must match.");
    Evolve<type_evolution_test::SchemaV1, decltype(from.first), EVOLVER>::template Go<INTO>(from.first, into.first);
    Evolve<type_evolution_test::SchemaV1, decltype(from.last), EVOLVER>::template Go<INTO>(from.last, into.last);
  }
};

template <typename EVOLVER>
struct Evolve<type_evolution_test::SchemaV1, type_evolution_test::SchemaV1::StructWithVectorOfNames, EVOLVER> {
  template <typename INTO>
  static void Go(const typename type_evolution_test::SchemaV1::StructWithVectorOfNames& from,
                 typename INTO::StructWithVectorOfNames& into) {
    static_assert(
        reflection::TotalFieldCounter<typename type_evolution_test::SchemaV1::StructWithVectorOfNames>::value ==
            reflection::TotalFieldCounter<typename INTO::StructWithVectorOfNames>::value,
        "Total field count for `StructWithVectorOfNames` must match.");
    Evolve<type_evolution_test::SchemaV1, decltype(from.w), EVOLVER>::template Go<INTO>(from.w, into.w);
  }
};

}  // namespace current::type_evolution
}  // namespace current

///////////////////////////////////////////////////////////////////////////////////////////////////
// }  // autogenerated code
///////////////////////////////////////////////////////////////////////////////////////////////////

// Custom evolution for `StructWithVector`.
CURRENT_TYPE_EVOLVER(V1ToV2Evolver, type_evolution_test::SchemaV1, StructWithVector, {
  into.string_ids.clear();
  into.string_ids.reserve(from.numerical_ids.size());
  for (const auto& cit : from.numerical_ids) {
    into.string_ids.push_back('@' + current::ToString(cit));
  }
});

// Custom evolution for `Name`.
CURRENT_TYPE_EVOLVER(V1ToV2Evolver, type_evolution_test::SchemaV1, Name, { into.full = from.first + ' ' + from.last; });

// Alternative custom evolution for `Name`.
CURRENT_TYPE_EVOLVER(AnotherV1ToV2Evolver, type_evolution_test::SchemaV1, Name, {
  into.full = from.last + ", " + from.first;
});

namespace type_evolution_test {
namespace arbitrarily_called_namespace {

CURRENT_STRUCT(SimpleStruct) {
  CURRENT_FIELD(x, int32_t, 201);
  CURRENT_FIELD(y, int32_t, 202);
  CURRENT_FIELD(z, std::string, "bar");
  CURRENT_DEFAULT_CONSTRUCTOR(SimpleStruct) {}
};

CURRENT_STRUCT(StructWithStruct) {
  CURRENT_FIELD(s, SimpleStruct);
  CURRENT_DEFAULT_CONSTRUCTOR(StructWithStruct) {}
};

// `StructWithVector` should evolve from `vector<int32_t> numerical_ids` in `SchemaV1` into `string_ids`.
CURRENT_STRUCT(StructWithVector) {
  CURRENT_FIELD(string_ids, std::vector<std::string>);
  CURRENT_DEFAULT_CONSTRUCTOR(StructWithVector) : string_ids({"@-1", "@112"}) {}
};

// clang-format off
CURRENT_ENUM(EnumClassType, bool) {
  False = false,
  True = true
};
// clang-format on

CURRENT_STRUCT(OtherTypes) {
  CURRENT_FIELD(enum_class, EnumClassType, EnumClassType::False);
  CURRENT_FIELD(optional, Optional<std::string>);
  CURRENT_DEFAULT_CONSTRUCTOR(OtherTypes) {}
};

CURRENT_STRUCT(StructWithVariant) {
  CURRENT_FIELD(v, (Variant<SimpleStruct, StructWithStruct, OtherTypes>));
  CURRENT_DEFAULT_CONSTRUCTOR(StructWithVariant) {}
};

// `Name` should evolve from two separate fields in `SchemaV1` into one full name field.
CURRENT_STRUCT(Name) {
  CURRENT_FIELD(full, std::string, "Friedrich Engels");
  CURRENT_DEFAULT_CONSTRUCTOR(Name) {}
};

CURRENT_STRUCT(StructWithVectorOfNames) {
  CURRENT_FIELD(w, std::vector<Name>);
  CURRENT_DEFAULT_CONSTRUCTOR(StructWithVectorOfNames) {}
};

}  // namespace arbitrarily_called_namespace

CURRENT_NAMESPACE(SchemaV2) {
  CURRENT_NAMESPACE_TYPE(SimpleStruct, arbitrarily_called_namespace::SimpleStruct);
  CURRENT_NAMESPACE_TYPE(StructWithStruct, arbitrarily_called_namespace::StructWithStruct);
  CURRENT_NAMESPACE_TYPE(StructWithVector, arbitrarily_called_namespace::StructWithVector);
  CURRENT_NAMESPACE_TYPE(EnumClassType, arbitrarily_called_namespace::EnumClassType);
  CURRENT_NAMESPACE_TYPE(OtherTypes, arbitrarily_called_namespace::OtherTypes);
  CURRENT_NAMESPACE_TYPE(StructWithVariant, arbitrarily_called_namespace::StructWithVariant);
  CURRENT_NAMESPACE_TYPE(Name, arbitrarily_called_namespace::Name);
  CURRENT_NAMESPACE_TYPE(StructWithVectorOfNames, arbitrarily_called_namespace::StructWithVectorOfNames);
};

}  // namespace type_evolution_test

TEST(TypeEvolutionTest, SimpleStruct) {
  using namespace type_evolution_test;
  {
    const SchemaV1::SimpleStruct from;
    EXPECT_EQ("{\"x\":101,\"y\":102,\"z\":\"foo\"}", JSON(from));
  }
  {
    const SchemaV2::SimpleStruct into;
    EXPECT_EQ("{\"x\":201,\"y\":202,\"z\":\"bar\"}", JSON(into));
  }
  {
    const SchemaV1::SimpleStruct original;
    SchemaV2::SimpleStruct converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::SimpleStruct>::template Go<SchemaV2>(original, converted);
    EXPECT_EQ("{\"x\":101,\"y\":102,\"z\":\"foo\"}", JSON(converted));
  }
  {
    // `V1ToV2Evolver` leaves `SimpleStruct` unaffected.
    using current::type_evolution::V1ToV2Evolver;
    const SchemaV1::SimpleStruct original;
    SchemaV2::SimpleStruct converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::SimpleStruct, V1ToV2Evolver>::template Go<SchemaV2>(original,
                                                                                                            converted);
    EXPECT_EQ("{\"x\":101,\"y\":102,\"z\":\"foo\"}", JSON(converted));
  }
}

TEST(TypeEvolutionTest, StructWithStruct) {
  using namespace type_evolution_test;
  {
    const SchemaV1::StructWithStruct from;
    EXPECT_EQ("{\"s\":{\"x\":101,\"y\":102,\"z\":\"foo\"}}", JSON(from));
  }
  {
    const SchemaV2::StructWithStruct into;
    EXPECT_EQ("{\"s\":{\"x\":201,\"y\":202,\"z\":\"bar\"}}", JSON(into));
  }
  {
    const SchemaV1::StructWithStruct original;
    SchemaV2::StructWithStruct converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithStruct>::template Go<SchemaV2>(original, converted);
    EXPECT_EQ("{\"s\":{\"x\":101,\"y\":102,\"z\":\"foo\"}}", JSON(converted));
  }
  {
    // `V1ToV2Evolver` leaves `StructWithStruct` unaffected.
    using current::type_evolution::V1ToV2Evolver;
    const SchemaV1::StructWithStruct original;
    SchemaV2::StructWithStruct converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithStruct, V1ToV2Evolver>::template Go<SchemaV2>(
        original, converted);
    EXPECT_EQ("{\"s\":{\"x\":101,\"y\":102,\"z\":\"foo\"}}", JSON(converted));
  }
}

TEST(TypeEvolutionTest, StructWithVector) {
  using namespace type_evolution_test;
  {
    const SchemaV1::StructWithVector from;
    EXPECT_EQ("8,50", current::strings::Join(from.numerical_ids, ','));
    const SchemaV2::StructWithVector into;
    EXPECT_EQ("@-1,@112", current::strings::Join(into.string_ids, ','));
  }
  {
    using current::type_evolution::V1ToV2Evolver;
    const SchemaV1::StructWithVector original;
    // The default evolution won't compile as `vector<int32_t> numerical_ids`
    // changes into `vector<string> string_ids`.
    // const SchemaV2::StructWithVector converted = current::type_evolution::Evolve<SchemaV1,
    // SchemaV1::StructWithVector>::template Go<SchemaV2>(original);
    SchemaV2::StructWithVector converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithVector, V1ToV2Evolver>::template Go<SchemaV2>(
        original, converted);
    EXPECT_EQ("@8,@50", current::strings::Join(converted.string_ids, ','));
  }
}

TEST(TypeEvolutionTest, StructWithVariant) {
  using namespace type_evolution_test;

  {
    SchemaV1::StructWithVariant from;
    from.v = SchemaV1::SimpleStruct();
    EXPECT_EQ("{\"x\":101,\"y\":102,\"z\":\"foo\"}", JSON(Value<SchemaV1::SimpleStruct>(from.v)));
  }
  {
    SchemaV1::StructWithVariant from;
    from.v = SchemaV1::StructWithStruct();
    EXPECT_EQ("{\"s\":{\"x\":101,\"y\":102,\"z\":\"foo\"}}", JSON(Value<SchemaV1::StructWithStruct>(from.v)));
  }

  {
    SchemaV2::StructWithVariant into;
    into.v = SchemaV2::SimpleStruct();
    EXPECT_EQ("{\"x\":201,\"y\":202,\"z\":\"bar\"}", JSON(Value<SchemaV2::SimpleStruct>(into.v)));
  }
  {
    SchemaV2::StructWithVariant into;
    into.v = SchemaV2::StructWithStruct();
    EXPECT_EQ("{\"s\":{\"x\":201,\"y\":202,\"z\":\"bar\"}}", JSON(Value<SchemaV2::StructWithStruct>(into.v)));
  }
  {
    SchemaV1::StructWithVariant original;
    original.v = SchemaV1::SimpleStruct();
    SchemaV2::StructWithVariant converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithVariant>::template Go<SchemaV2>(original, converted);
    ASSERT_TRUE(Exists<SchemaV2::SimpleStruct>(converted.v));
    EXPECT_EQ("{\"x\":101,\"y\":102,\"z\":\"foo\"}", JSON(Value<SchemaV2::SimpleStruct>(converted.v)));
  }
  {
    SchemaV1::StructWithVariant original;
    original.v = SchemaV1::StructWithStruct();
    SchemaV2::StructWithVariant converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithVariant>::template Go<SchemaV2>(original, converted);
    ASSERT_TRUE(Exists<SchemaV2::StructWithStruct>(converted.v));
    EXPECT_EQ("{\"s\":{\"x\":101,\"y\":102,\"z\":\"foo\"}}", JSON(Value<SchemaV2::StructWithStruct>(converted.v)));
  }
}

TEST(TypeEvolutionTest, NameWithDifferentEvolvers) {
  using namespace type_evolution_test;
  {
    const SchemaV2::Name SchemaV2;
    EXPECT_EQ("Friedrich Engels", SchemaV2.full);
  }
  {
    using current::type_evolution::V1ToV2Evolver;
    const SchemaV1::Name original;
    // The default evolution won't compile as the structure layout changes from `SchemaV1` to `SchemaV2`.
    // const SchemaV2::Name converted = current::type_evolution::Evolve<SchemaV1,
    //     SchemaV1::Name>::template Go<SchemaV2>(original);
    SchemaV2::Name converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::Name, V1ToV2Evolver>::template Go<SchemaV2>(original,
                                                                                                    converted);
    EXPECT_EQ("Karl Marx", converted.full);
  }
  {
    // Using alternative evolution for `Name`.
    using current::type_evolution::AnotherV1ToV2Evolver;
    const SchemaV1::Name original;
    SchemaV2::Name converted;
    current::type_evolution::Evolve<SchemaV1, SchemaV1::Name, AnotherV1ToV2Evolver>::template Go<SchemaV2>(original,
                                                                                                           converted);
    EXPECT_EQ("Marx, Karl", converted.full);
  }
}

#ifndef JUST_GENERATE_THAT_GOLDEN_FILE
// Programmatically use the autogenerated schema and the default type evolver generated for it.
#include "golden/schema.h"
using SchemaXX = USERSPACE_F055D51FBF78DB84;

// Custom evolution from the autogenerated `SimpleStruct`.
CURRENT_TYPE_EVOLVER(AddFortyTwoToX, SchemaXX, SimpleStruct, {
  into.x = from.x + 42;
  into.y = from.y;
  into.z = from.z;
});

// Custom evolution that behaves differently for `SimpleStruct` and `StructWithStruct`.
CURRENT_TYPE_EVOLVER(AddOneOrTwoToX, SchemaXX, SimpleStruct, {
  into.x = from.x + 1;
  into.y = from.y;
  into.z = from.z;
});
CURRENT_TYPE_EVOLVER(AddOneOrTwoToX, SchemaXX, StructWithStruct, {
  into.s.x = from.s.x + 2;
  into.s.y = from.s.y;
  into.s.z = from.s.z;
});
#endif  // JUST_GENERATE_THAT_GOLDEN_FILE

TEST(TypeEvolutionTest, AutogeneratedCurrentStructsAreReadyForEvolution) {
  using namespace type_evolution_test;
  using namespace current::reflection;

  {
    // Validate or overwrite the autogenerated schema header file.
    const std::string golden_filename = current::FileSystem::JoinPath("golden", "schema.h");
    StructSchema schema;
    schema.AddType<typename SchemaV1::SimpleStruct>();
    schema.AddType<typename SchemaV1::StructWithStruct>();
    schema.AddType<typename SchemaV1::StructWithVariant>();
    schema.AddType<typename SchemaV1::Name>();
    schema.AddType<typename SchemaV1::StructWithVectorOfNames>();
    const std::string golden = schema.GetSchemaInfo().Describe<Language::Current>();
    if (!FLAGS_write_type_evolution_golden_files) {
      // clang-format off
      EXPECT_EQ(current::FileSystem::ReadFileAsString(golden_filename), golden)
          << "\n# Run the following two commands:\n"
          << '\n'
          << "./.current/test --write_type_evolution_golden_files && touch test.cc\n"
          << "echo \"using SchemaXX = $(grep \"CURRENT_NAMESPACE(\" golden/schema.h | cut -f2 -d'(' | cut -f1 -d')');\"\n"
          << '\n'
          << "# And paste the resulting `using SchemaXX = ...` line into `test.cc` instead of the current one.\n";
      // clang-format on
    } else {
      current::FileSystem::WriteStringToFile(golden, golden_filename.c_str());
    }
  }

#ifndef JUST_GENERATE_THAT_GOLDEN_FILE
  // Confirm the types we are dealing with are indeed different.
  static_assert(!std::is_same<typename SchemaV1::SimpleStruct, typename SchemaXX::SimpleStruct>::value, "");

  { // Plain `SimpleStruct` tests, just copy the fields over, no evolution.
   {// Local `SimpleStruct` into autogenerated `SimpleStruct`.
    typename SchemaV1::SimpleStruct from;
  typename SchemaXX::SimpleStruct into;
  from.x = 100002;
  from.y = 100003;
  from.z = "dima";
  current::type_evolution::Evolve<SchemaV1, SchemaV1::SimpleStruct>::template Go<SchemaXX>(from, into);
  EXPECT_EQ(100002, into.x);
  EXPECT_EQ(100003, into.y);
  EXPECT_EQ("dima", into.z);
}
{
  // Autogenerated `SimpleStruct` into local `SimpleStruct`.
  typename SchemaXX::SimpleStruct from;
  typename SchemaV1::SimpleStruct into;
  from.x = 400005;
  from.y = 400006;
  from.z = "max";
  current::type_evolution::Evolve<SchemaXX, SchemaXX::SimpleStruct>::template Go<SchemaV1>(from, into);
  EXPECT_EQ(400005, into.x);
  EXPECT_EQ(400006, into.y);
  EXPECT_EQ("max", into.z);
}
}

{ // Plain `StructWithStruct` tests, just copy the fields over, no evolution.
 {// Local `StructWithStruct` into autogenerated `StructWithStruct`.
  typename SchemaV1::StructWithStruct from;
typename SchemaXX::StructWithStruct into;
from.s.x = 188882;
from.s.y = 188883;
from.s.z = "dima";
current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithStruct>::template Go<SchemaXX>(from, into);
EXPECT_EQ(188882, into.s.x);
EXPECT_EQ(188883, into.s.y);
EXPECT_EQ("dima", into.s.z);
}
{
  // Autogenerated `StructWithStruct` into local `StructWithStruct`.
  typename SchemaXX::StructWithStruct from;
  typename SchemaV1::StructWithStruct into;
  from.s.x = 488885;
  from.s.y = 488886;
  from.s.z = "max";
  current::type_evolution::Evolve<SchemaXX, SchemaXX::StructWithStruct>::template Go<SchemaV1>(from, into);
  EXPECT_EQ(488885, into.s.x);
  EXPECT_EQ(488886, into.s.y);
  EXPECT_EQ("max", into.s.z);
}
}

{ // Plain `Name` tests, just copy the fields over, no evolution.
 {// Local `Name` into autogenerated `Name`.
  typename SchemaV1::Name from;
typename SchemaXX::Name into;
from.first = "Dima";
from.last = "Korolev";
current::type_evolution::Evolve<SchemaV1, SchemaV1::Name>::template Go<SchemaXX>(from, into);
EXPECT_EQ("Dima", into.first);
EXPECT_EQ("Korolev", into.last);
}
{
  // Autogenerated `Name` into local `Name`.
  typename SchemaXX::Name from;
  typename SchemaV1::Name into;
  from.first = "Max";
  from.last = "Zhurovich";
  current::type_evolution::Evolve<SchemaXX, SchemaXX::Name>::template Go<SchemaV1>(from, into);
  EXPECT_EQ("Max", into.first);
  EXPECT_EQ("Zhurovich", into.last);
}
}

{ // `AddFortyTwoToX` adds 42 to `.x` of `SimpleStruct`.
 {// Run with a plain `SimpleStruct`.
  typename SchemaXX::SimpleStruct from;
typename SchemaV1::SimpleStruct into;
from.x = 0;
from.y = 0;
from.z = "doit";
current::type_evolution::Evolve<SchemaXX, SchemaXX::SimpleStruct, current::type_evolution::AddFortyTwoToX>::template Go<
    SchemaV1>(from, into);
EXPECT_EQ(42, into.x);
EXPECT_EQ(0, into.y);
EXPECT_EQ("doit", into.z);
}
{
  // Run with `SimpleStruct` within `StructWithStruct`.
  typename SchemaXX::StructWithStruct from;
  typename SchemaV1::StructWithStruct into;
  from.s.x = 0;
  from.s.y = 0;
  from.s.z = "doit";
  current::type_evolution::Evolve<SchemaXX, SchemaXX::StructWithStruct, current::type_evolution::AddFortyTwoToX>::
      template Go<SchemaV1>(from, into);
  EXPECT_EQ(42, into.s.x);
  EXPECT_EQ(0, into.s.y);
  EXPECT_EQ("doit", into.s.z);
}
}

{ // `AddOneOrTwoToX` adds 1 to `.x` of `SimpleStruct` or 2 to `.s.x` of `StructWithStruct`.
 {// Run with a plain `SimpleStruct`.
  typename SchemaXX::SimpleStruct from;
typename SchemaV1::SimpleStruct into;
from.x = 0;
from.y = 0;
from.z = "doit";
current::type_evolution::Evolve<SchemaXX, SchemaXX::SimpleStruct, current::type_evolution::AddOneOrTwoToX>::template Go<
    SchemaV1>(from, into);
EXPECT_EQ(1, into.x);
EXPECT_EQ(0, into.y);
EXPECT_EQ("doit", into.z);
}
{
  // Run with `SimpleStruct` within `StructWithStruct`.
  typename SchemaXX::StructWithStruct from;
  typename SchemaV1::StructWithStruct into;
  from.s.x = 0;
  from.s.y = 0;
  from.s.z = "doit";
  current::type_evolution::Evolve<SchemaXX, SchemaXX::StructWithStruct, current::type_evolution::AddOneOrTwoToX>::
      template Go<SchemaV1>(from, into);
  EXPECT_EQ(2, into.s.x);
  EXPECT_EQ(0, into.s.y);
  EXPECT_EQ("doit", into.s.z);
}
}

{ // Plain `Variant<SimpleStruct, StructWithStruct>` tests, just copy the fields over, no evolution.
 {// Local `Variant<...>` into autogenerated `Variant<...>`.
  // The `Variant<>`-originating evolver implemented manually above is used.
  {Variant<typename SchemaV1::SimpleStruct, typename SchemaV1::StructWithStruct, typename SchemaV1::OtherTypes> from;
Variant<typename SchemaXX::SimpleStruct, typename SchemaXX::StructWithStruct, typename SchemaXX::OtherTypes> into;
from = typename SchemaV1::SimpleStruct();
Value<SchemaV1::SimpleStruct>(from).x = 1;
current::type_evolution::Evolve<SchemaV1, decltype(from)>::template Go<SchemaXX>(from, into);
EXPECT_TRUE(Exists<typename SchemaXX::SimpleStruct>(into));
EXPECT_FALSE(Exists<typename SchemaXX::StructWithStruct>(into));
EXPECT_EQ(1, Value<typename SchemaXX::SimpleStruct>(into).x);
}

{
  Variant<typename SchemaV1::SimpleStruct, typename SchemaV1::StructWithStruct, typename SchemaV1::OtherTypes> from;
  Variant<typename SchemaXX::SimpleStruct, typename SchemaXX::StructWithStruct, typename SchemaXX::OtherTypes> into;
  from = typename SchemaV1::StructWithStruct();
  Value<SchemaV1::StructWithStruct>(from).s.x = 2;
  current::type_evolution::Evolve<
      SchemaV1,
      Variant<typename SchemaV1::SimpleStruct, typename SchemaV1::StructWithStruct, typename SchemaV1::OtherTypes>>::
      template Go<SchemaXX>(from, into);
  EXPECT_FALSE(Exists<typename SchemaXX::SimpleStruct>(into));
  EXPECT_TRUE(Exists<typename SchemaXX::StructWithStruct>(into));
  EXPECT_EQ(2, Value<typename SchemaXX::StructWithStruct>(into).s.x);
}
}

{
  // Autogenerated `Variant<...>` into local `Variant<...>`.
  // The autogenerated `Variant<>`-originating evolver is used.
  {
    Variant<typename SchemaXX::SimpleStruct, typename SchemaXX::StructWithStruct, typename SchemaXX::OtherTypes> from;
    Variant<typename SchemaV1::SimpleStruct, typename SchemaV1::StructWithStruct, typename SchemaV1::OtherTypes> into;
    from = typename SchemaXX::SimpleStruct();
    Value<SchemaXX::SimpleStruct>(from).x = 3;
    current::type_evolution::Evolve<
        SchemaXX,
        Variant<typename SchemaXX::SimpleStruct, typename SchemaXX::StructWithStruct, typename SchemaXX::OtherTypes>>::
        template Go<SchemaV1>(from, into);
    EXPECT_TRUE(Exists<typename SchemaV1::SimpleStruct>(into));
    EXPECT_FALSE(Exists<typename SchemaV1::StructWithStruct>(into));
    EXPECT_EQ(3, Value<typename SchemaV1::SimpleStruct>(into).x);
  }

  {
    Variant<typename SchemaXX::SimpleStruct, typename SchemaXX::StructWithStruct, typename SchemaXX::OtherTypes> from;
    Variant<typename SchemaV1::SimpleStruct, typename SchemaV1::StructWithStruct, typename SchemaV1::OtherTypes> into;
    from = typename SchemaXX::StructWithStruct();
    Value<SchemaXX::StructWithStruct>(from).s.x = 4;
    current::type_evolution::Evolve<
        SchemaXX,
        Variant<typename SchemaXX::SimpleStruct, typename SchemaXX::StructWithStruct, typename SchemaXX::OtherTypes>>::
        template Go<SchemaV1>(from, into);
    EXPECT_FALSE(Exists<typename SchemaV1::SimpleStruct>(into));
    EXPECT_TRUE(Exists<typename SchemaV1::StructWithStruct>(into));
    EXPECT_EQ(4, Value<typename SchemaV1::StructWithStruct>(into).s.x);
  }
}
}

{ // Plain `StructWithVariant` tests, just copy the fields over, no evolution.
 {// Local `StructWithVariant` into autogenerated `StructWithVariant`.
  // The `Variant<>`-originating evolver implemented manually above is used.
  {typename SchemaV1::StructWithVariant from;
typename SchemaXX::StructWithVariant into;
from.v = typename SchemaV1::SimpleStruct();
Value<SchemaV1::SimpleStruct>(from.v).x = 1;
current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithVariant>::template Go<SchemaXX>(from, into);
EXPECT_TRUE(Exists<typename SchemaXX::SimpleStruct>(into.v));
EXPECT_FALSE(Exists<typename SchemaXX::StructWithStruct>(into.v));
EXPECT_EQ(1, Value<typename SchemaXX::SimpleStruct>(into.v).x);
}

{
  typename SchemaV1::StructWithVariant from;
  typename SchemaXX::StructWithVariant into;
  from.v = typename SchemaV1::StructWithStruct();
  Value<SchemaV1::StructWithStruct>(from.v).s.x = 2;
  current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithVariant>::template Go<SchemaXX>(from, into);
  EXPECT_FALSE(Exists<typename SchemaXX::SimpleStruct>(into.v));
  EXPECT_TRUE(Exists<typename SchemaXX::StructWithStruct>(into.v));
  EXPECT_EQ(2, Value<typename SchemaXX::StructWithStruct>(into.v).s.x);
}
}

{
  // Autogenerated `StructWithVariant` into local `StructWithVariant`.
  // The autogenerated `Variant<>`-originating evolver is used.
  {
    typename SchemaXX::StructWithVariant from;
    typename SchemaV1::StructWithVariant into;
    from.v = typename SchemaXX::SimpleStruct();
    Value<SchemaXX::SimpleStruct>(from.v).x = 3;
    current::type_evolution::Evolve<SchemaXX, SchemaXX::StructWithVariant>::template Go<SchemaV1>(from, into);
    EXPECT_TRUE(Exists<typename SchemaV1::SimpleStruct>(into.v));
    EXPECT_FALSE(Exists<typename SchemaV1::StructWithStruct>(into.v));
    EXPECT_EQ(3, Value<typename SchemaV1::SimpleStruct>(into.v).x);
  }

  {
    typename SchemaXX::StructWithVariant from;
    typename SchemaV1::StructWithVariant into;
    from.v = typename SchemaXX::StructWithStruct();
    Value<SchemaXX::StructWithStruct>(from.v).s.x = 4;
    current::type_evolution::Evolve<SchemaXX, SchemaXX::StructWithVariant>::template Go<SchemaV1>(from, into);
    EXPECT_FALSE(Exists<typename SchemaV1::SimpleStruct>(into.v));
    EXPECT_TRUE(Exists<typename SchemaV1::StructWithStruct>(into.v));
    EXPECT_EQ(4, Value<typename SchemaV1::StructWithStruct>(into.v).s.x);
  }
}
}

{ // Plain `StructWithVectorOfNames` tests, just copy the fields over, no evolution.
 {// Local `StructWithVectorOfNames` into autogenerated `StructWithVectorOfNames`.
  typename SchemaV1::StructWithVectorOfNames from;
typename SchemaXX::StructWithVectorOfNames into;
from.w.emplace_back("Dima", "Korolev");
from.w.emplace_back("Max", "Zhurovich");
current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithVectorOfNames>::template Go<SchemaXX>(from, into);
ASSERT_EQ(2u, into.w.size());
EXPECT_EQ("Dima", into.w[0].first);
EXPECT_EQ("Korolev", into.w[0].last);
EXPECT_EQ("Max", into.w[1].first);
EXPECT_EQ("Zhurovich", into.w[1].last);
}
{
  typename SchemaXX::StructWithVectorOfNames from;
  typename SchemaV1::StructWithVectorOfNames into;
  // `.emplace_back` can't really work on autogenerated struct. -- D.K.
  from.w.push_back([] {
    typename SchemaXX::Name u;
    u.first = "Max";
    u.last = "Zhurovich";
    return u;
  }());
  from.w.push_back([] {
    typename SchemaXX::Name u;
    u.first = "Dima";
    u.last = "Korolev";
    return u;
  }());
  current::type_evolution::Evolve<SchemaXX, SchemaXX::StructWithVectorOfNames>::template Go<SchemaV1>(from, into);
  ASSERT_EQ(2u, into.w.size());
  EXPECT_EQ("Max", into.w[0].first);
  EXPECT_EQ("Zhurovich", into.w[0].last);
  EXPECT_EQ("Dima", into.w[1].first);
  EXPECT_EQ("Korolev", into.w[1].last);
}
}

{
  // Confirm type evolution kicks in when running over an `std::vector<>`.
  using current::type_evolution::V1ToV2Evolver;
  using current::type_evolution::AnotherV1ToV2Evolver;
  {
    // Evolve `SchemaV1`'s `StructWithVectorOfNames` into V2 using `V1ToV2Evolver`.
    typename SchemaV1::StructWithVectorOfNames original;
    typename SchemaV2::StructWithVectorOfNames evoluted;
    original.w.emplace_back("Dima", "Korolev");
    original.w.emplace_back("Max", "Zhurovich");
    current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithVectorOfNames, V1ToV2Evolver>::template Go<SchemaV2>(
        original, evoluted);
    ASSERT_EQ(2u, evoluted.w.size());
    EXPECT_EQ("Dima Korolev", evoluted.w[0].full);
    EXPECT_EQ("Max Zhurovich", evoluted.w[1].full);
  }
  {
    // Evolve `SchemaV1`'s `StructWithVectorOfNames` into V2 using `AnotherV1ToV2Evolver`.
    typename SchemaV1::StructWithVectorOfNames original;
    typename SchemaV2::StructWithVectorOfNames evoluted;
    original.w.emplace_back("Max", "Zhurovich");
    original.w.emplace_back("Dima", "Korolev");
    current::type_evolution::Evolve<SchemaV1, SchemaV1::StructWithVectorOfNames, AnotherV1ToV2Evolver>::template Go<
        SchemaV2>(original, evoluted);
    ASSERT_EQ(2u, evoluted.w.size());
    EXPECT_EQ("Zhurovich, Max", evoluted.w[0].full);
    EXPECT_EQ("Korolev, Dima", evoluted.w[1].full);
  }
}
#endif  // JUST_GENERATE_THAT_GOLDEN_FILE
}

namespace type_evolution_test {
namespace pre_evolution {
CURRENT_STRUCT(User, SchemaV1::Name) { CURRENT_FIELD(key, std::string); };
CURRENT_STORAGE_FIELD_ENTRY(OrderedDictionary, User, PersistedUser);
CURRENT_STORAGE(Storage) { CURRENT_STORAGE_FIELD(user, PersistedUser); };
}  // namespace type_evolution_test::pre_evolution
namespace post_evolution {
CURRENT_STRUCT(User, SchemaV2::Name) { CURRENT_FIELD(key, std::string); };
CURRENT_STORAGE_FIELD_ENTRY(OrderedDictionary, User, PersistedUser);
CURRENT_STORAGE(Storage) { CURRENT_STORAGE_FIELD(user, PersistedUser); };
}  // namespace type_evolution_test::pre_evolution
}  // namespace type_evolution_test

#include "golden/storage_schema_original.h"
#include "golden/storage_schema_evolved.h"

// Default evolver copy-pasted from the boilerplate to evolve the `Transaction`, type of which has changed.
CURRENT_TYPE_EVOLVER(OriginalStorageToModifiedStorageEvolver, SchemaOriginalStorage, Transaction, {
  CURRENT_NATURAL_EVOLVE(SchemaOriginalStorage, SchemaModifiedStorage, from.meta, into.meta);
  CURRENT_NATURAL_EVOLVE(SchemaOriginalStorage, SchemaModifiedStorage, from.mutations, into.mutations);
});

// Custom evolution for `Name` stored as part of Storage's transactions.
CURRENT_TYPE_EVOLVER(OriginalStorageToOriginalStorageEvolver, SchemaOriginalStorage, Name, {
  into.first = current::strings::ToUpper(from.first);
  into.last = current::strings::ToUpper(from.last);
});

CURRENT_TYPE_EVOLVER(OriginalStorageToModifiedStorageEvolver, SchemaOriginalStorage, Name, {
  into.full = from.last + ", " + from.first[0];
});

TEST(TypeEvolutionTest, StorageInnerTypes) {
  // Test the plain `Name` type goes through.
  typename SchemaOriginalStorage::Name foo;
  foo.first = "Ayn";
  foo.last = "Rand";
  {
    typename SchemaOriginalStorage::Name bar;
    current::type_evolution::Evolve<SchemaOriginalStorage,
                                    typename SchemaOriginalStorage::Name>::template Go<SchemaOriginalStorage>(foo, bar);
    EXPECT_EQ("{\"first\":\"Ayn\",\"last\":\"Rand\"}", JSON(bar));
  }
  {
    typename SchemaOriginalStorage::Name baz;
    current::type_evolution::Evolve<
        SchemaOriginalStorage,
        typename SchemaOriginalStorage::Name,
        current::type_evolution::OriginalStorageToOriginalStorageEvolver>::template Go<SchemaOriginalStorage>(foo, baz);
    EXPECT_EQ("{\"first\":\"AYN\",\"last\":\"RAND\"}", JSON(baz));
  }
  {
    typename SchemaModifiedStorage::Name meh;
    current::type_evolution::Evolve<
        SchemaOriginalStorage,
        typename SchemaOriginalStorage::Name,
        current::type_evolution::OriginalStorageToModifiedStorageEvolver>::template Go<SchemaModifiedStorage>(foo, meh);
    EXPECT_EQ("{\"full\":\"Rand, A\"}", JSON(meh));
  }
}

TEST(TypeEvolutionTest, StorageTransactionsEvolution) {
  current::time::ResetToZero();

  const std::string pre_evolution_file_name =
      current::FileSystem::JoinPath(FLAGS_type_evolution_test_tmpdir, "pre_evolution");
  const auto pre_evolution_file_remover = current::FileSystem::ScopedRmFile(pre_evolution_file_name);

  const std::string post_evolution_file_name =
      current::FileSystem::JoinPath(FLAGS_type_evolution_test_tmpdir, "post_evolution");
  const auto post_evolution_file_remover = current::FileSystem::ScopedRmFile(post_evolution_file_name);

  using pre_evolution_transaction_t = current::storage::transaction_t<type_evolution_test::pre_evolution::Storage>;
  using post_evolution_transaction_t = current::storage::transaction_t<type_evolution_test::post_evolution::Storage>;

  static_assert(
      !std::is_same<typename type_evolution_test::SchemaV1::Name, typename type_evolution_test::SchemaV2::Name>::value,
      "");
  static_assert(!std::is_same<pre_evolution_transaction_t, post_evolution_transaction_t>::value, "");

  {
    using namespace current::reflection;

    {
      StructSchema struct_schema;
      struct_schema.AddType<typename type_evolution_test::SchemaV1::Name>();
      EXPECT_EQ(
          "namespace current_userspace {\n"
          "struct Name {\n"
          "  std::string first;\n"
          "  std::string last;\n"
          "};\n"
          "}  // namespace current_userspace\n",
          struct_schema.GetSchemaInfo().Describe<Language::CPP>(false));
    }
    {
      StructSchema struct_schema;
      struct_schema.AddType<typename type_evolution_test::SchemaV2::Name>();
      EXPECT_EQ(
          "namespace current_userspace {\n"
          "struct Name {\n"
          "  std::string full;\n"
          "};\n"
          "}  // namespace current_userspace\n",
          struct_schema.GetSchemaInfo().Describe<Language::CPP>(false));
    }
    {
      StructSchema struct_schema;
      struct_schema.AddType<type_evolution_test::pre_evolution::User>();
      EXPECT_EQ(
          "namespace current_userspace {\n"
          "struct Name {\n"
          "  std::string first;\n"
          "  std::string last;\n"
          "};\n"
          "struct User : Name {\n"
          "  std::string key;\n"
          "};\n"
          "}  // namespace current_userspace\n",
          struct_schema.GetSchemaInfo().Describe<Language::CPP>(false));
    }

    {
      StructSchema struct_schema;
      struct_schema.AddType<type_evolution_test::post_evolution::User>();
      EXPECT_EQ(
          "namespace current_userspace {\n"
          "struct Name {\n"
          "  std::string full;\n"
          "};\n"
          "struct User : Name {\n"
          "  std::string key;\n"
          "};\n"
          "}  // namespace current_userspace\n",
          struct_schema.GetSchemaInfo().Describe<Language::CPP>(false));
    }

    {
      StructSchema struct_schema;
      struct_schema.AddType<pre_evolution_transaction_t>();
      EXPECT_EQ(
          "namespace current_userspace {\n"
          "struct TransactionMeta {\n"
          "  std::chrono::microseconds begin_us;\n"
          "  std::chrono::microseconds end_us;\n"
          "  std::map<std::string, std::string> fields;\n"
          "};\n"
          "struct Name {\n"
          "  std::string first;\n"
          "  std::string last;\n"
          "};\n"
          "struct User : Name {\n"
          "  std::string key;\n"
          "};\n"
          "struct PersistedUserUpdated {\n"
          "  std::chrono::microseconds us;\n"
          "  User data;\n"
          "};\n"
          "struct PersistedUserDeleted {\n"
          "  std::chrono::microseconds us;\n"
          "  std::string key;\n"
          "};\n"
          "using Variant_B_PersistedUserUpdated_PersistedUserDeleted_E = Variant<PersistedUserUpdated, "
          "PersistedUserDeleted>;\n"
          "struct Transaction_T9226378158835221611 {\n"
          "  TransactionMeta meta;\n"
          "  std::vector<Variant_B_PersistedUserUpdated_PersistedUserDeleted_E> mutations;\n"
          "};\n"
          "}  // namespace current_userspace\n",
          struct_schema.GetSchemaInfo().Describe<Language::CPP>(false));
    }
    {
      StructSchema struct_schema;
      struct_schema.AddType<post_evolution_transaction_t>();
      EXPECT_EQ(
          "namespace current_userspace {\n"
          "struct TransactionMeta {\n"
          "  std::chrono::microseconds begin_us;\n"
          "  std::chrono::microseconds end_us;\n"
          "  std::map<std::string, std::string> fields;\n"
          "};\n"
          "struct Name {\n"
          "  std::string full;\n"
          "};\n"
          "struct User : Name {\n"
          "  std::string key;\n"
          "};\n"
          "struct PersistedUserUpdated {\n"
          "  std::chrono::microseconds us;\n"
          "  User data;\n"
          "};\n"
          "struct PersistedUserDeleted {\n"
          "  std::chrono::microseconds us;\n"
          "  std::string key;\n"
          "};\n"
          "using Variant_B_PersistedUserUpdated_PersistedUserDeleted_E = Variant<PersistedUserUpdated, "
          "PersistedUserDeleted>;\n"
          "struct Transaction_T9221660456409416796 {\n"
          "  TransactionMeta meta;\n"
          "  std::vector<Variant_B_PersistedUserUpdated_PersistedUserDeleted_E> mutations;\n"
          "};\n"
          "}  // namespace current_userspace\n",
          struct_schema.GetSchemaInfo().Describe<Language::CPP>(false));
    }

    current::sherlock::Stream<pre_evolution_transaction_t, current::persistence::File> pre_evolution_stream(
        pre_evolution_file_name);
    current::sherlock::Stream<post_evolution_transaction_t, current::persistence::File> post_evolution_stream(
        post_evolution_file_name);

    {
      using namespace current::reflection;

      {
        StructSchema struct_schema;
        struct_schema.AddType<pre_evolution_transaction_t>();
        const std::string schema_cpp = struct_schema.GetSchemaInfo().Describe<Language::Current>(
            NamespaceToExpose("SchemaOriginalStorage").template AddType<pre_evolution_transaction_t>("Transaction"));

        const auto autogenerated_schema_file = current::FileSystem::JoinPath("golden", "storage_schema_original.h");

        if (FLAGS_write_type_evolution_golden_files) {
          current::FileSystem::WriteStringToFile(schema_cpp, autogenerated_schema_file.c_str());
        }

        EXPECT_EQ(schema_cpp, current::FileSystem::ReadFileAsString(autogenerated_schema_file));
      }

      {
        StructSchema struct_schema;
        struct_schema.AddType<post_evolution_transaction_t>();
        const std::string schema_cpp = struct_schema.GetSchemaInfo().Describe<Language::Current>(
            NamespaceToExpose("SchemaModifiedStorage").template AddType<post_evolution_transaction_t>("Transaction"));

        const auto autogenerated_schema_file = current::FileSystem::JoinPath("golden", "storage_schema_evolved.h");

        if (FLAGS_write_type_evolution_golden_files) {
          current::FileSystem::WriteStringToFile(schema_cpp, autogenerated_schema_file.c_str());
        }

        EXPECT_EQ(schema_cpp, current::FileSystem::ReadFileAsString(autogenerated_schema_file));
      }
    }

    // Fill in the original storage with some data.
    {
      using pre_storage_t = type_evolution_test::pre_evolution::Storage<SherlockInMemoryStreamPersister>;
      using post_storage_t = type_evolution_test::post_evolution::Storage<SherlockInMemoryStreamPersister>;
      pre_storage_t pre_evolution_storage;

      // Two transactions with two mutations in the second transaction, to test evolution through.
      pre_evolution_storage
          .ReadWriteTransaction([](MutableFields<pre_storage_t> fields) {
            type_evolution_test::pre_evolution::User karl;
            karl.key = "karl";
            fields.user.Add(karl);
          })
          .Wait();

      pre_evolution_storage
          .ReadWriteTransaction([](MutableFields<pre_storage_t> fields) {
            {
              type_evolution_test::pre_evolution::User dima;
              dima.key = "dima";
              dima.first = "Dima";
              dima.last = "Korolev";
              fields.user.Add(dima);
            }
            {
              type_evolution_test::pre_evolution::User max;
              max.key = "max";
              max.first = "Max";
              max.last = "Zhurovich";
              fields.user.Add(max);
            }
          })
          .Wait();

      // As mutations took place, create two storage log files to replay, one before and one after evolution.
      //
      // Note: This test could read shorter if instead of generating the output stream
      // from a memory-persisted storage, the storage could populate the output stream itself.
      // I decided to take the longer route to have stream persistence file creation
      // implemented explicitly, side-by-side with and without type evolution. -- D.K.
      //
      // TODO(dkorolev): These `Internal*()` should go away.
      const auto& persister = pre_evolution_storage.InternalExposeStream().InternalExposePersister();
      ASSERT_EQ(persister.Size(), 2u) << "Must have exactly two transactions persisted.";

      for (const auto& e : persister.Iterate()) {
        const typename pre_storage_t::transaction_t& original_transaction = e.entry;

        // The next line would work just fine, but let's test deep copy through. -- D.K.
        // pre_evolution_stream.Publish(original_transaction, e.idx_ts.us);

        // NOTE: The code below uses `ParseJSON(JSON(xxx))` constructs to "cast" C++ types between each other.
        // As structures are declared several times, their C++ types are different,
        // and, as RTTI dispatching uses C++ type IDs, not Current type IDs, `reinterpret_cast` doesn't do it.
        // This "problem" would not exist outside the unit test, as the right types are always passed in.

        {
          // Publish the original, pre-evolved, transaction.

          const auto cast_original_transaction =
              ParseJSON<typename SchemaOriginalStorage::Transaction>(JSON(original_transaction));

          typename SchemaOriginalStorage::Transaction cast_type_evolved_transaction;

          // Still apply the `OriginalStorageToOriginalStorageEvolver` to uppercase names.
          current::type_evolution::Evolve<SchemaOriginalStorage,
                                          typename SchemaOriginalStorage::Transaction,
                                          current::type_evolution::OriginalStorageToOriginalStorageEvolver>::
              template Go<SchemaOriginalStorage>(cast_original_transaction, cast_type_evolved_transaction);

          pre_evolution_stream.Publish(
              ParseJSON<typename pre_storage_t::transaction_t>(JSON(cast_type_evolved_transaction)), e.idx_ts.us);
        }

        {
          // Publish the evolved, old-to-new-storage, transformed transaction.

          const auto cast_original_transaction =
              ParseJSON<typename SchemaOriginalStorage::Transaction>(JSON(original_transaction));

          typename SchemaModifiedStorage::Transaction cast_type_evolved_transaction;

          // Apply the `OriginalStorageToModifiedStorageEvolver` to convert `first+last` name into `full` name.
          current::type_evolution::Evolve<SchemaOriginalStorage,
                                          typename SchemaOriginalStorage::Transaction,
                                          current::type_evolution::OriginalStorageToModifiedStorageEvolver>::
              template Go<SchemaModifiedStorage>(cast_original_transaction, cast_type_evolved_transaction);

          post_evolution_stream.Publish(
              ParseJSON<typename post_storage_t::transaction_t>(JSON(cast_type_evolved_transaction)), e.idx_ts.us);
        }
      }
    }

    // Compare original, pre-type-evolved, and generated, post-type-evolved, storage logs against golden files.
    {
      const auto golden_storage_pre_evolution_file_name =
          current::FileSystem::JoinPath("golden", "storage_pre_evolution.txt");
      const auto golden_storage_post_evolution_file_name =
          current::FileSystem::JoinPath("golden", "storage_post_evolution.txt");

      if (FLAGS_write_type_evolution_golden_files) {
        current::FileSystem::WriteStringToFile(current::FileSystem::ReadFileAsString(pre_evolution_file_name),
                                               golden_storage_pre_evolution_file_name.c_str());
        current::FileSystem::WriteStringToFile(current::FileSystem::ReadFileAsString(post_evolution_file_name),
                                               golden_storage_post_evolution_file_name.c_str());
      }

      EXPECT_EQ(current::FileSystem::ReadFileAsString(golden_storage_pre_evolution_file_name),
                current::FileSystem::ReadFileAsString(pre_evolution_file_name));
      EXPECT_EQ(current::FileSystem::ReadFileAsString(golden_storage_post_evolution_file_name),
                current::FileSystem::ReadFileAsString(post_evolution_file_name));
    }

    // Sanity check: confirm the replayed pre-evolution storage contains the data UPPERCASED.
    {
      using restored_pre_storage_t = type_evolution_test::pre_evolution::Storage<SherlockStreamPersister>;
      restored_pre_storage_t replayed_pre_evolution_storage(pre_evolution_file_name);

      replayed_pre_evolution_storage
          .ReadOnlyTransaction([](ImmutableFields<restored_pre_storage_t> fields) {
            EXPECT_EQ(3u, fields.user.Size());
            EXPECT_TRUE(Exists(fields.user["karl"]));
            EXPECT_FALSE(Exists(fields.user["bernie"]));
            EXPECT_FALSE(Exists(fields.user["donald"]));
            EXPECT_TRUE(Exists(fields.user["dima"]));
            EXPECT_TRUE(Exists(fields.user["max"]));
            EXPECT_EQ("KARL", Value(fields.user["karl"]).first);
            EXPECT_EQ("MARX", Value(fields.user["karl"]).last);
            EXPECT_EQ("DIMA", Value(fields.user["dima"]).first);
            EXPECT_EQ("KOROLEV", Value(fields.user["dima"]).last);
            EXPECT_EQ("MAX", Value(fields.user["max"]).first);
            EXPECT_EQ("ZHUROVICH", Value(fields.user["max"]).last);
          })
          .Wait();
    }

    // The full end-to-end schema test: confirm type-evolved transactions s.a. "First Last" became "Last, F".
    {
      using restored_post_storage_t = type_evolution_test::post_evolution::Storage<SherlockStreamPersister>;
      restored_post_storage_t replayed_post_evolution_storage(post_evolution_file_name);

      replayed_post_evolution_storage
          .ReadOnlyTransaction([](ImmutableFields<restored_post_storage_t> fields) {
            EXPECT_EQ(3u, fields.user.Size());
            EXPECT_TRUE(Exists(fields.user["karl"]));
            EXPECT_FALSE(Exists(fields.user["bernie"]));
            EXPECT_FALSE(Exists(fields.user["donald"]));
            EXPECT_TRUE(Exists(fields.user["dima"]));
            EXPECT_TRUE(Exists(fields.user["max"]));
            EXPECT_EQ("Marx, K", Value(fields.user["karl"]).full);
            EXPECT_EQ("Korolev, D", Value(fields.user["dima"]).full);
            EXPECT_EQ("Zhurovich, M", Value(fields.user["max"]).full);
          })
          .Wait();
    }
  }
}

#endif  // CURRENT_TYPE_SYSTEM_EVOLUTION_TEST_CC
